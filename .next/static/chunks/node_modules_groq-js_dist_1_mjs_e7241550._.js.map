{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"1.mjs","sources":["file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/values/Path.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/values/dateHelpers.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/values/utils.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/values/StreamValue.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/equality.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/matching.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/ordering.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/operators.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/scope.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/evaluate.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/constantEvaluate.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/nodeTypes.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/array.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/dateTime.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/keyPath.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/selector.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/diff.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/delta.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/documents.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/geo.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/string.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/global.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/math.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/pt.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/pt.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/releases.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/sanity.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/text.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/scoring.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/pipeFunctions.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/evaluator/functions/index.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/markProcessor.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/rawParser.js","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/traversal.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/parser.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/typeEvaluator/optimizations.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/typeEvaluator/typeHelpers.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/typeEvaluator/booleans.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/typeEvaluator/functions.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/typeEvaluator/matching.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/typeEvaluator/scope.ts","file:///Users/isseemii/app/letterseed/node_modules/groq-js/src/typeEvaluator/typeEvaluate.ts"],"sourcesContent":["function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n","const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n","import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport type {\n  AnyStaticValue,\n  ArrayValue,\n  BooleanValue,\n  DateTimeValue,\n  GroqType,\n  NullValue,\n  PathValue,\n  StringValue,\n  Value,\n} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  asStatic(): this {\n    return this\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): DateTimeValue | NullValue {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): AnyStaticValue {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): StringValue {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): PathValue {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\nexport function fromArray(val: unknown[]): ArrayValue {\n  return new StaticValue(val, 'array')\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns a normalized JavaScript value. This eliminates internal values\n * such as DateTime and Path by turning them into the JSON representation.\n */\nexport function toJS(val: AnyStaticValue): unknown {\n  const normalized = maybeNormalize(val.data)\n  if (normalized === undefined) return val.data\n  return normalized\n}\n\n/**\n * maybeNormalize eliminates custom values such as DateTime and Path.\n * This method returns `undefined` in the scenario where the data contains no\n * custom values and the data is already normalized.\n */\nfunction maybeNormalize(data: unknown): unknown | undefined {\n  if (data === null || typeof data === 'undefined') return\n\n  if (Array.isArray(data)) {\n    let result: undefined | unknown[]\n    for (let i = 0; i < data.length; i++) {\n      let normalized = maybeNormalize(data[i])\n      if (normalized !== undefined && result === undefined) {\n        // This is the first value which had to be converted.\n        result = data.slice(0, i)\n      }\n\n      if (result !== undefined) {\n        if (normalized === undefined) normalized = data[i]\n        result.push(normalized)\n      }\n    }\n\n    return result\n  }\n\n  if (typeof data === 'object') {\n    if ('toJSON' in data && typeof data.toJSON === 'function') {\n      return data.toJSON()\n    }\n\n    const entries = Object.entries(data)\n    let result: undefined | Record<string, unknown>\n\n    for (let i = 0; i < entries.length; i++) {\n      const [key, value] = entries[i]!\n      let normalized = maybeNormalize(value)\n      if (normalized !== undefined && result === undefined) {\n        // This is the first value which had to be converted.\n        result = Object.fromEntries(entries.slice(0, i))\n      }\n\n      if (result !== undefined) {\n        if (normalized === undefined) normalized = value\n        result[key] = normalized\n      }\n    }\n\n    return result\n  }\n\n  return\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n","import type {ArrayValue, Value} from './types'\nimport {StaticValue} from './utils'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any[]> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async asStatic(): Promise<ArrayValue> {\n    return new StaticValue(await this.get(), 'array')\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    let currentRejector: (reason?: any) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve, reject) => {\n        currentResolver = resolve\n        currentRejector = reject\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      try {\n        for await (const value of this.generator()) {\n          this.data.push(value)\n          tick()\n        }\n\n        this.isDone = true\n        tick()\n      } catch (error) {\n        currentRejector(error)\n      }\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n","import type {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  if (a === null || b === null) return a === b\n  const typeOfA = typeof a\n  const typeOfB = typeof b\n  if (typeOfA === 'undefined' && typeOfB === 'undefined') return true\n  if (typeOfA === 'function' && typeOfB === 'function') return a === b\n  if (typeOfA === 'object' && typeOfB === 'object') {\n    const keysOfA = Object.keys(a)\n    const keysOfB = Object.keys(b)\n    if (keysOfA.length !== keysOfB.length) return false\n    for (const key of keysOfA) {\n      if (!deepEqual(a[key], b[key])) return false\n    }\n    return true\n  }\n  return a === b\n}\n","import type {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i'),\n  )\n}\n\nexport type GatheredText<T> = {\n  parts: T[]\n  /** This is true if all of the values in the array were strings. */\n  success: boolean\n}\n\nexport function gatherText<T>(\n  value: Value,\n  flatMap: (str: string) => T[],\n): Promise<GatheredText<T>> | GatheredText<T> {\n  if (value.type === 'string') {\n    return {parts: flatMap(value.data), success: true}\n  }\n\n  if (value.type === 'array') {\n    let success = true\n    const parts: T[] = []\n\n    for (const part of value.data) {\n      if (typeof part === 'string') {\n        parts.push(...flatMap(part))\n      } else {\n        success = false\n      }\n    }\n\n    return {parts, success}\n  }\n\n  if (value.type === 'stream') {\n    return (async () => {\n      let success = true\n      const parts: T[] = []\n\n      for await (const part of value) {\n        if (part.type === 'string') {\n          parts.push(...flatMap(part.data))\n        } else {\n          success = false\n        }\n      }\n      return {parts, success}\n    })()\n  }\n\n  return {parts: [], success: false}\n}\n","import {getType, type GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n","import type {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  type Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {\n  gatherText,\n  matchAnalyzePattern,\n  matchText,\n  matchTokenize,\n  type GatheredText,\n  type Pattern,\n  type Token,\n} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  'in': function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.type === 'array') {\n      for (const b of right.data) {\n        if (isEqual(left, fromJS(b))) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    if (right.type === 'stream') {\n      return (async () => {\n        for await (const b of right) {\n          if (isEqual(left, b)) {\n            return TRUE_VALUE\n          }\n        }\n\n        return FALSE_VALUE\n      })()\n    }\n\n    return NULL_VALUE\n  },\n\n  'match': function match(left, right) {\n    const tokens = gatherText(left, (part) => matchTokenize(part))\n    const patterns = gatherText(right, (part) => matchAnalyzePattern(part))\n\n    const process = (tokens: GatheredText<Token>, patterns: GatheredText<Pattern>) => {\n      if (!patterns.success) {\n        return FALSE_VALUE\n      }\n\n      const matched = matchText(tokens.parts, patterns.parts)\n\n      return matched ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if ('then' in tokens || 'then' in patterns) {\n      return (async () => process(await tokens, await patterns))()\n    }\n\n    return process(tokens, patterns)\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n","import type {Value} from '../values'\nimport type {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null,\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromArray,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  type AnyStaticValue,\n  type ObjectValue,\n  type Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport type {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(node: ExprNode, scope: Scope): Value | PromiseLike<Value> {\n  return executeAsync(node, scope)\n}\n\nexport function executeSync(node: ExprNode, scope: Scope): AnyStaticValue {\n  const exec = EXECUTORS[node.type]\n  return exec.executeSync(node as any, scope)\n}\n\nexport function executeAsync(node: ExprNode, scope: Scope): Promise<Value> {\n  const exec = EXECUTORS[node.type]\n  return exec.executeAsync(node as any, scope)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: Executor<NarrowNode<ExprNode, key>>\n}\n\n/**\n * Defines an executor which is only valid in `evaluateAsync`.\n *\n * @deprecated This is a temporary helper. Over time we want everything to be both sync and async.\n **/\nexport function asyncOnlyExecutor<N = ExprNode>(\n  executeAsync: (node: N, scope: Scope) => Promise<Value>,\n): Executor<N> {\n  return {\n    executeSync() {\n      throw new Error('executeSync not supported')\n    },\n    executeAsync,\n  }\n}\n\nexport function constantExecutor<N = ExprNode>(fn: (node: N, scope: Scope) => Value): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const value = fn(node, scope)\n      if (value.type === 'stream') throw new Error('Stream encountered in evaluateSync')\n      return value\n    },\n    async executeAsync(node, scope) {\n      return fn(node, scope)\n    },\n  }\n}\n\nexport function mappedExecutor<N = ExprNode>(\n  map: (node: N) => ExprNode[],\n  reduce: (node: N, ...values: AnyStaticValue[]) => Value,\n): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const nodes = map(node)\n      const values = nodes.map((node) => executeSync(node, scope))\n      const value = reduce(node, ...values)\n      if (value.type === 'stream')\n        throw new Error('Stream/iterator not supported in synchronous mode')\n      return value\n    },\n    async executeAsync(node, scope) {\n      const nodes = map(node)\n      const values = await Promise.all(\n        nodes.map((node) => executeAsync(node, scope).then((value) => value.asStatic())),\n      )\n      return reduce(node, ...values)\n    },\n  }\n}\n\nexport const STOP_ITERATOR = Symbol()\n\n/**\n * An executor for procesing an array into a single value.\n *\n * @param map Returns a set of nodes which will be executed.\n * @param init Called once to produce an internal state.\n * @param reduce Called per item in the array.\n * @param wrap Turns the state into a static value.\n */\nexport function arrayReducerExecutor<N = ExprNode, State = unknown>(\n  map: (node: N) => {array: ExprNode; args?: ExprNode[]},\n  init: (node: N, ...args: AnyStaticValue[]) => State,\n  reduce: (\n    node: N,\n    state: State,\n    item: unknown,\n    ...args: AnyStaticValue[]\n  ) => State | typeof STOP_ITERATOR,\n  wrap: (state: State) => AnyStaticValue,\n): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const {array: arrayNode, args: argNodes = []} = map(node)\n      const arr = executeSync(arrayNode, scope)\n      if (arr.type !== 'array') return NULL_VALUE\n      const args = argNodes.map((node) => executeSync(node, scope))\n      let state = init(node, ...args)\n      for (const item of arr.data) {\n        const result = reduce(node, state, item, ...args)\n        if (result === STOP_ITERATOR) return NULL_VALUE\n        state = result\n      }\n      return wrap(state)\n    },\n    async executeAsync(node, scope) {\n      const {array: arrayNode, args: argNodes = []} = map(node)\n      const arr = await executeAsync(arrayNode, scope)\n      if (arr.type !== 'array' && arr.type !== 'stream') return NULL_VALUE\n\n      const args = await Promise.all(\n        argNodes.map((node) => executeAsync(node, scope).then((v) => v.asStatic())),\n      )\n\n      let state = init(node, ...args)\n\n      if (arr.type === 'stream') {\n        for await (const item of arr) {\n          const result = reduce(node, state, await item.get(), ...args)\n          if (result === STOP_ITERATOR) return NULL_VALUE\n          state = result\n        }\n      } else {\n        for (const item of arr.data) {\n          const result = reduce(node, state, item, ...args)\n          if (result === STOP_ITERATOR) return NULL_VALUE\n          state = result\n        }\n      }\n\n      return wrap(state)\n    },\n  }\n}\n\n/**\n * An executor which processes an array and returns another array.\n */\nexport function arrayExecutor<N = ExprNode, S = undefined>(\n  map: (node: N) => {array: ExprNode; inner?: ExprNode; state?: S},\n  reduce: (node: N, item: unknown, inner: unknown, state?: S) => Iterable<unknown>,\n  {hidden = false}: {hidden?: boolean} = {},\n): Executor<N> {\n  return {\n    executeSync(node, scope) {\n      const mapping = map(node)\n      const arr = executeSync(mapping.array, scope)\n      if (arr.type !== 'array') return NULL_VALUE\n      const result: unknown[] = []\n      for (const item of arr.data) {\n        let inner: unknown\n        if (mapping.inner) {\n          const newScope = hidden\n            ? scope.createHidden(fromJS(item))\n            : scope.createNested(fromJS(item))\n          inner = executeSync(mapping.inner, newScope).data\n        }\n        for (const entry of reduce(node, item, inner, mapping.state)) {\n          result.push(entry)\n        }\n      }\n      return fromArray(result)\n    },\n\n    async executeAsync(node, scope) {\n      const mapping = map(node)\n      const arr = await executeAsync(mapping.array, scope)\n      if (!arr.isArray()) return NULL_VALUE\n\n      return new StreamValue(async function* () {\n        for await (const item of arr) {\n          let inner: unknown\n          if (mapping.inner) {\n            const newScope = hidden ? scope.createHidden(item) : scope.createNested(item)\n            const innerValue = await executeAsync(mapping.inner, newScope)\n            inner = await innerValue.get()\n          }\n          for (const entry of reduce(node, await item.get(), inner, mapping.state)) {\n            yield fromJS(entry)\n          }\n        }\n      })\n    },\n  }\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This: constantExecutor((_, scope) => {\n    return scope.value\n  }),\n\n  SelectorNested: constantExecutor(() => {\n    throw new Error('Unexpected node type: SelectorNested')\n  }),\n\n  SelectorFuncCall: constantExecutor(() => {\n    throw new Error('Unexpected node type: SelectorFuncCall')\n  }),\n\n  Everything: constantExecutor((_, scope) => {\n    return scope.source\n  }),\n\n  Parameter: constantExecutor(({name}, scope) => {\n    return fromJS(scope.params[name])\n  }),\n\n  Context: constantExecutor(({key}, scope) => {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  }),\n\n  Parent: constantExecutor(({n}, scope) => {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  }),\n\n  OpCall: {\n    async executeAsync({op, left, right}, scope) {\n      const func = operators[op]\n      if (!func) {\n        throw new Error(`Unknown operator: ${op}`)\n      }\n      const leftValue = await executeAsync(left, scope)\n      const rightValue = await executeAsync(right, scope)\n\n      return func(leftValue, rightValue)\n    },\n    executeSync({op, left, right}, scope) {\n      const func = operators[op]\n      if (!func) {\n        throw new Error(`Unknown operator: ${op}`)\n      }\n      const leftValue = executeSync(left, scope)\n      const rightValue = executeSync(right, scope)\n\n      const result = func(leftValue, rightValue)\n      if ('then' in result || result.type === 'stream')\n        throw new Error(`Operator ${op} not possible in evaluteSync`)\n      return result\n    },\n  },\n\n  Select: {\n    executeSync({alternatives, fallback}, scope) {\n      for (const alt of alternatives) {\n        const altCond = executeSync(alt.condition, scope)\n        if (altCond.type === 'boolean' && altCond.data === true) {\n          return executeSync(alt.value, scope)\n        }\n      }\n\n      if (fallback) {\n        return executeSync(fallback, scope)\n      }\n\n      return NULL_VALUE\n    },\n\n    async executeAsync({alternatives, fallback}, scope) {\n      for (const alt of alternatives) {\n        const altCond = await executeAsync(alt.condition, scope)\n        if (altCond.type === 'boolean' && altCond.data === true) {\n          return executeAsync(alt.value, scope)\n        }\n      }\n\n      if (fallback) {\n        return executeAsync(fallback, scope)\n      }\n\n      return NULL_VALUE\n    },\n  },\n\n  InRange: mappedExecutor(\n    ({base, left, right}) => [base, left, right],\n    ({isInclusive}, value, leftValue, rightValue) => {\n      const leftCmp = partialCompare(value.data, leftValue.data)\n      if (leftCmp === null) {\n        return NULL_VALUE\n      }\n      const rightCmp = partialCompare(value.data, rightValue.data)\n      if (rightCmp === null) {\n        return NULL_VALUE\n      }\n\n      if (isInclusive) {\n        return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n      }\n\n      return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n    },\n  ),\n\n  Filter: arrayExecutor(\n    ({base, expr}) => ({array: base, inner: expr}),\n    function* (_, elem, inner) {\n      if (inner === true) yield elem\n    },\n  ),\n\n  Projection: {\n    executeSync({base, expr}, scope) {\n      const baseValue = executeSync(base, scope)\n\n      if (baseValue.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const newScope = scope.createNested(baseValue)\n      return executeSync(expr, newScope)\n    },\n\n    async executeAsync({base, expr}, scope) {\n      const baseValue = await executeAsync(base, scope)\n      if (baseValue.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const newScope = scope.createNested(baseValue)\n      return executeAsync(expr, newScope)\n    },\n  },\n\n  FuncCall: {\n    executeAsync({func, args}, scope) {\n      return func.executeAsync(args, scope)\n    },\n\n    executeSync({func, args}, scope) {\n      return func.executeSync(args, scope)\n    },\n  },\n\n  PipeFuncCall: {\n    async executeAsync({func, base, args}, scope) {\n      const baseValue = await executeAsync(base, scope)\n      if (baseValue.type !== 'stream' && baseValue.type !== 'array') return NULL_VALUE\n      return func.executeAsync({base: baseValue, args}, scope)\n    },\n\n    executeSync({func, base, args}, scope) {\n      const baseValue = executeSync(base, scope)\n      if (baseValue.type !== 'array') return NULL_VALUE\n      return func.executeSync({base: baseValue, args}, scope)\n    },\n  },\n\n  AccessAttribute: mappedExecutor(\n    ({base}) => [base || {type: 'This'}],\n    ({name}, value) => {\n      if (value.type === 'object') {\n        if (value.data.hasOwnProperty(name)) {\n          return fromJS(value.data[name]) as ObjectValue\n        }\n      }\n\n      return NULL_VALUE\n    },\n  ),\n\n  AccessElement: mappedExecutor(\n    ({base}) => [base],\n    ({index}, baseValue) => {\n      if (baseValue.type !== 'array') return NULL_VALUE\n      const data = baseValue.data\n      const finalIndex = index < 0 ? index + data.length : index\n      return fromJS(data[finalIndex])\n    },\n  ),\n\n  Slice: mappedExecutor(\n    ({base}) => [base],\n    ({left, right, isInclusive}, baseValue) => {\n      if (baseValue.type !== 'array') {\n        return NULL_VALUE\n      }\n\n      // OPT: Here we can optimize when either indices are >= 0\n      const array = baseValue.data\n\n      let leftIdx = left\n      let rightIdx = right\n\n      // Handle negative index\n      if (leftIdx < 0) {\n        leftIdx = array.length + leftIdx\n      }\n      if (rightIdx < 0) {\n        rightIdx = array.length + rightIdx\n      }\n\n      // Convert from inclusive to exclusive index\n      if (isInclusive) {\n        rightIdx++\n      }\n\n      if (leftIdx < 0) {\n        leftIdx = 0\n      }\n      if (rightIdx < 0) {\n        rightIdx = 0\n      }\n\n      // Note: At this point the indices might point out-of-bound, but\n      // .slice handles this correctly.\n\n      return fromArray(array.slice(leftIdx, rightIdx))\n    },\n  ),\n\n  Deref: {\n    executeSync({base}, scope) {\n      const value = executeSync(base, scope)\n\n      if (value.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const id = value.data['_ref']\n      if (typeof id !== 'string') {\n        return NULL_VALUE\n      }\n\n      if (scope.context.dereference) {\n        const value = scope.context.dereference({_ref: id})\n        if (value && typeof value === 'object' && 'then' in value) {\n          throw new Error('Dereference returned promise in synchronous mode')\n        }\n\n        return fromJS(value) as AnyStaticValue\n      }\n\n      if (scope.source.type !== 'array') {\n        return NULL_VALUE\n      }\n\n      for (const doc of scope.source.data) {\n        if (doc && typeof doc === 'object' && '_id' in doc && id === doc['_id']) {\n          return fromJS(doc) as ObjectValue\n        }\n      }\n\n      return NULL_VALUE\n    },\n\n    async executeAsync({base}, scope) {\n      const value = await executeAsync(base, scope)\n\n      if (!scope.source.isArray()) {\n        return NULL_VALUE\n      }\n\n      if (value.type !== 'object') {\n        return NULL_VALUE\n      }\n\n      const id = value.data['_ref']\n      if (typeof id !== 'string') {\n        return NULL_VALUE\n      }\n\n      if (scope.context.dereference) {\n        return fromJS(await scope.context.dereference({_ref: id}))\n      }\n\n      for await (const doc of scope.source) {\n        if (doc.type === 'object' && id === doc.data['_id']) {\n          return doc\n        }\n      }\n\n      return NULL_VALUE\n    },\n  },\n\n  Value: constantExecutor(({value}) => {\n    return fromJS(value)\n  }),\n\n  Group: {\n    executeSync({base}, scope) {\n      return executeSync(base, scope)\n    },\n    executeAsync({base}, scope) {\n      return executeAsync(base, scope)\n    },\n  },\n\n  Object: {\n    executeSync({attributes}, scope) {\n      const result: {[key: string]: any} = {}\n      for (const attr of attributes) {\n        const attrType = attr.type\n        switch (attr.type) {\n          case 'ObjectAttributeValue': {\n            const value = executeSync(attr.value, scope)\n            result[attr.name] = value.data\n            break\n          }\n\n          case 'ObjectConditionalSplat': {\n            const cond = executeSync(attr.condition, scope)\n            if (cond.type !== 'boolean' || cond.data === false) {\n              continue\n            }\n\n            const value = executeSync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          case 'ObjectSplat': {\n            const value = executeSync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          default:\n            throw new Error(`Unknown node type: ${attrType}`)\n        }\n      }\n      return fromJS(result) as ObjectValue\n    },\n\n    async executeAsync({attributes}, scope) {\n      const result: {[key: string]: any} = {}\n      for (const attr of attributes) {\n        const attrType = attr.type\n        switch (attr.type) {\n          case 'ObjectAttributeValue': {\n            const value = await executeAsync(attr.value, scope)\n            result[attr.name] = await value.get()\n            break\n          }\n\n          case 'ObjectConditionalSplat': {\n            const cond = await executeAsync(attr.condition, scope)\n            if (cond.type !== 'boolean' || cond.data === false) {\n              continue\n            }\n\n            const value = await executeAsync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          case 'ObjectSplat': {\n            const value = await executeAsync(attr.value, scope)\n            if (value.type === 'object') {\n              Object.assign(result, value.data)\n            }\n            break\n          }\n\n          default:\n            throw new Error(`Unknown node type: ${attrType}`)\n        }\n      }\n      return fromJS(result)\n    },\n  },\n\n  Array: {\n    executeSync({elements}, scope) {\n      const result = []\n      for (const element of elements) {\n        const value = executeSync(element.value, scope)\n        if (element.isSplat) {\n          if (value.type === 'array') {\n            for (const v of value.data) {\n              result.push(v)\n            }\n          }\n        } else {\n          result.push(value.data)\n        }\n      }\n\n      return fromArray(result)\n    },\n\n    async executeAsync({elements}, scope) {\n      return new StreamValue(async function* () {\n        for (const element of elements) {\n          const value = await executeAsync(element.value, scope)\n          if (element.isSplat) {\n            if (value.isArray()) {\n              for await (const v of value) {\n                yield v\n              }\n            }\n          } else {\n            yield value\n          }\n        }\n      })\n    },\n  },\n\n  Tuple: constantExecutor(() => {\n    throw new Error('tuples can not be evaluated')\n  }),\n\n  Or: mappedExecutor(\n    ({left, right}) => [left, right],\n    (_, leftValue, rightValue) => {\n      if (leftValue.type === 'boolean') {\n        if (leftValue.data === true) {\n          return TRUE_VALUE\n        }\n      }\n\n      if (rightValue.type === 'boolean') {\n        if (rightValue.data === true) {\n          return TRUE_VALUE\n        }\n      }\n\n      if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n        return NULL_VALUE\n      }\n\n      return FALSE_VALUE\n    },\n  ),\n\n  And: mappedExecutor(\n    ({left, right}) => [left, right],\n    (_, leftValue, rightValue) => {\n      if (leftValue.type === 'boolean') {\n        if (leftValue.data === false) {\n          return FALSE_VALUE\n        }\n      }\n\n      if (rightValue.type === 'boolean') {\n        if (rightValue.data === false) {\n          return FALSE_VALUE\n        }\n      }\n\n      if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n        return NULL_VALUE\n      }\n\n      return TRUE_VALUE\n    },\n  ),\n\n  Not: mappedExecutor(\n    ({base}) => [base],\n    (_, value) => {\n      if (value.type !== 'boolean') {\n        return NULL_VALUE\n      }\n      return value.data ? FALSE_VALUE : TRUE_VALUE\n    },\n  ),\n\n  Neg: mappedExecutor(\n    ({base}) => [base],\n    (_, value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    },\n  ),\n\n  Pos: mappedExecutor(\n    ({base}) => [base],\n    (_, value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    },\n  ),\n\n  Asc: constantExecutor(() => NULL_VALUE),\n  Desc: constantExecutor(() => NULL_VALUE),\n\n  ArrayCoerce: {\n    executeSync({base}, scope) {\n      const value = executeSync(base, scope)\n      return value.isArray() ? value : NULL_VALUE\n    },\n\n    async executeAsync({base}, scope) {\n      const value = await executeAsync(base, scope)\n      return value.isArray() ? value : NULL_VALUE\n    },\n  },\n\n  Map: arrayExecutor(\n    ({base, expr}) => ({array: base, inner: expr}),\n    function* (_, _item, inner) {\n      yield inner\n    },\n    {hidden: true},\n  ),\n\n  FlatMap: arrayExecutor(\n    ({base, expr}) => ({array: base, inner: expr}),\n    function* (_, _item, inner) {\n      if (Array.isArray(inner)) {\n        for (const innerInner of inner) {\n          yield innerInner\n        }\n      } else {\n        yield inner\n      }\n    },\n    {hidden: true},\n  ),\n}\n\n/**\n * Evaluates a query.\n * @internal\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {},\n): Value | PromiseLike<Value> {\n  return executeAsync(tree, scopeFromOptions(options))\n}\n\n/**\n * Evaluates a query synchronously.\n *\n * This currently only supports a tiny subset of the GROQ language.\n * @internal\n */\nexport function evaluateQuerySync(tree: ExprNode, options: EvaluateOptions = {}): AnyStaticValue {\n  return executeSync(tree, scopeFromOptions(options))\n}\n\nfunction scopeFromOptions(options: EvaluateOptions): Scope {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  return new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n      dereference: options.dereference,\n    },\n    null,\n  )\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, type AnyStaticValue} from '../values'\nimport {executeSync} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n      return canConstantEvaluate(node.base)\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null,\n)\n\nexport function tryConstantEvaluate(node: ExprNode): AnyStaticValue | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): AnyStaticValue {\n  return executeSync(node, DUMMY_SCOPE)\n}\n","import type {GroqFunction, GroqPipeFunction} from './evaluator/functions'\n\n/** Any sort of node which appears as syntax */\nexport type SyntaxNode = ExprNode | ArrayElementNode | ObjectAttributeNode | SelectAlternativeNode\n\nexport type ObjectAttributeNode =\n  | ObjectAttributeValueNode\n  | ObjectConditionalSplatNode\n  | ObjectSplatNode\n\n/**\n * A node which can be evaluated into a value.\n * @public\n */\nexport type ExprNode =\n  | AccessAttributeNode\n  | AccessElementNode\n  | AndNode\n  | ArrayNode\n  | ArrayCoerceNode\n  | AscNode\n  | ContextNode\n  | DerefNode\n  | DescNode\n  | EverythingNode\n  | FilterNode\n  | FlatMapNode\n  | FuncCallNode\n  | GroupNode\n  | InRangeNode\n  | MapNode\n  | NegNode\n  | NotNode\n  | ObjectNode\n  | OpCallNode\n  | OrNode\n  | ParameterNode\n  | ParentNode\n  | PipeFuncCallNode\n  | PosNode\n  | ProjectionNode\n  | SelectNode\n  | SelectorNode\n  | SliceNode\n  | ThisNode\n  | TupleNode\n  | ValueNode\n\nexport type OpCall =\n  | '=='\n  | '!='\n  | '>'\n  | '>='\n  | '<'\n  | '<='\n  | '+'\n  | '-'\n  | '*'\n  | '/'\n  | '%'\n  | '**'\n  | 'in'\n  | 'match'\n\n/** The base interface for SyntaxNode. */\nexport interface BaseNode {\n  type: string\n}\n\nexport interface AndNode extends BaseNode {\n  type: 'And'\n  left: ExprNode\n  right: ExprNode\n}\n\nexport interface ArrayElementNode extends BaseNode {\n  type: 'ArrayElement'\n  value: ExprNode\n  isSplat: boolean\n}\n\nexport interface ArrayNode extends BaseNode {\n  type: 'Array'\n  elements: ArrayElementNode[]\n}\n\nexport interface ArrayCoerceNode<Base = ExprNode> extends BaseNode {\n  type: 'ArrayCoerce'\n  base: Base\n}\n\nexport interface AscNode extends BaseNode {\n  type: 'Asc'\n  base: ExprNode\n}\n\nexport interface ContextNode extends BaseNode {\n  type: 'Context'\n  key: string\n}\n\nexport interface DerefNode extends BaseNode {\n  type: 'Deref'\n  base: ExprNode\n}\n\nexport interface DescNode extends BaseNode {\n  type: 'Desc'\n  base: ExprNode\n}\n\nexport interface EverythingNode extends BaseNode {\n  type: 'Everything'\n}\n\nexport interface FuncCallNode extends BaseNode {\n  type: 'FuncCall'\n  func: GroqFunction\n  namespace: string\n  name: string\n  args: ExprNode[]\n}\n\nexport interface GroupNode<Base = ExprNode> extends BaseNode {\n  type: 'Group'\n  base: Base\n}\n\nexport interface InRangeNode extends BaseNode {\n  type: 'InRange'\n  base: ExprNode\n  left: ExprNode\n  right: ExprNode\n  isInclusive: boolean\n}\n\nexport interface NegNode extends BaseNode {\n  type: 'Neg'\n  base: ExprNode\n}\n\nexport interface NotNode extends BaseNode {\n  type: 'Not'\n  base: ExprNode\n}\n\nexport interface ObjectAttributeValueNode extends BaseNode {\n  type: 'ObjectAttributeValue'\n  name: string\n  value: ExprNode\n}\n\nexport interface ObjectConditionalSplatNode extends BaseNode {\n  type: 'ObjectConditionalSplat'\n  condition: ExprNode\n  value: ExprNode\n}\n\nexport interface ObjectNode extends BaseNode {\n  type: 'Object'\n  attributes: ObjectAttributeNode[]\n}\n\nexport interface ObjectSplatNode extends BaseNode {\n  type: 'ObjectSplat'\n  value: ExprNode\n}\n\nexport interface OpCallNode extends BaseNode {\n  type: 'OpCall'\n  op: OpCall\n  left: ExprNode\n  right: ExprNode\n}\n\nexport interface OrNode extends BaseNode {\n  type: 'Or'\n  left: ExprNode\n  right: ExprNode\n}\n\nexport interface ParameterNode extends BaseNode {\n  type: 'Parameter'\n  name: string\n}\n\nexport interface ParentNode extends BaseNode {\n  type: 'Parent'\n  n: number\n}\n\nexport interface PipeFuncCallNode extends BaseNode {\n  type: 'PipeFuncCall'\n  func: GroqPipeFunction\n  base: ExprNode\n  name: string\n  args: ExprNode[]\n}\n\nexport interface PosNode extends BaseNode {\n  type: 'Pos'\n  base: ExprNode\n}\n\nexport interface SelectAlternativeNode extends BaseNode {\n  type: 'SelectAlternative'\n  condition: ExprNode\n  value: ExprNode\n}\n\nexport interface SelectNode extends BaseNode {\n  type: 'Select'\n  alternatives: SelectAlternativeNode[]\n  fallback?: ExprNode\n}\n\nexport type SelectorNode =\n  | AccessAttributeNode<SelectorNode>\n  | SelectorFuncCallNode\n  | GroupNode<SelectorNode>\n  | TupleNode<SelectorNode>\n  | ArrayCoerceNode<SelectorNode>\n  | FilterNode<SelectorNode>\n  | SelectorNestedNode\nexport function isSelectorNode(node: BaseNode): node is SelectorNode {\n  return [\n    'AccessAttribute',\n    'SelectorFuncCall',\n    'Group',\n    'Tuple',\n    'ArrayCoerce',\n    'Filter',\n    'SelectorNested',\n  ].includes(node.type)\n}\n\nexport interface SelectorFuncCallNode extends BaseNode {\n  type: 'SelectorFuncCall'\n  name: 'anywhere'\n  arg: ExprNode\n}\n\nexport type SelectorNested =\n  | AccessAttributeNode<SelectorNode>\n  | ArrayCoerceNode<SelectorNode>\n  | FilterNode<SelectorNode>\n  | GroupNode<SelectorNode>\n  | TupleNode<SelectorNode>\nexport function isSelectorNested(node: BaseNode): node is SelectorNested {\n  return ['AccessAttribute', 'ArrayCoerce', 'Filter', 'Group', 'Tuple', 'SelectorNested'].includes(\n    node.type,\n  )\n}\n\nexport interface SelectorNestedNode extends BaseNode {\n  type: 'SelectorNested'\n  base: SelectorNode\n  nested: SelectorNested\n}\n\nexport interface ThisNode extends BaseNode {\n  type: 'This'\n}\n\nexport interface TupleNode<Base = ExprNode> extends BaseNode {\n  type: 'Tuple'\n  members: Array<Base>\n}\n\nexport interface ValueNode<P = any> {\n  type: 'Value'\n  value: P\n}\n\nexport interface FlatMapNode extends BaseNode {\n  type: 'FlatMap'\n  base: ExprNode\n  expr: ExprNode\n}\n\nexport interface MapNode extends BaseNode {\n  type: 'Map'\n  base: ExprNode\n  expr: ExprNode\n}\n\nexport interface AccessAttributeNode<T = ExprNode> extends BaseNode {\n  type: 'AccessAttribute'\n  base?: T\n  name: string\n}\n\nexport interface AccessElementNode extends BaseNode {\n  type: 'AccessElement'\n  base: ExprNode\n  index: number\n}\n\nexport interface SliceNode extends BaseNode {\n  type: 'Slice'\n  base: ExprNode\n  left: number\n  right: number\n  isInclusive: boolean\n}\n\nexport interface FilterNode<Base = ExprNode> extends BaseNode {\n  type: 'Filter'\n  base: Base\n  expr: ExprNode\n}\n\nexport interface ProjectionNode extends BaseNode {\n  type: 'Projection'\n  base: ExprNode\n  expr: ExprNode\n}\n","import type {FunctionSet} from '.'\nimport {FALSE_VALUE, fromJS, fromString, getType, NULL_VALUE, TRUE_VALUE} from '../../values'\nimport {isEqual} from '../equality'\nimport {arrayExecutor, mappedExecutor} from '../evaluate'\n\nconst array: FunctionSet = {}\n\narray['join'] = mappedExecutor(\n  (args) => args,\n  (_, arr, sep) => {\n    if (arr.type !== 'array') {\n      return NULL_VALUE\n    }\n    if (sep.type !== 'string') {\n      return NULL_VALUE\n    }\n    let buf = ''\n    let needSep = false\n    for (const elem of arr.data) {\n      if (needSep) {\n        buf += sep.data\n      }\n      switch (getType(elem)) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          buf += `${elem}`\n          break\n        default:\n          return NULL_VALUE\n      }\n      needSep = true\n    }\n    return fromString(buf)\n  },\n)\narray['join'].arity = 2\n\narray['compact'] = arrayExecutor(\n  ([array]) => ({array: array!}),\n  function* (_, item) {\n    if (item !== null) yield item\n  },\n)\narray['compact'].arity = 1\n\narray['unique'] = arrayExecutor(\n  (args) => ({array: args[0]!, state: new Set()}),\n  function* (_node, iter, _inner, added) {\n    switch (getType(iter)) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        if (!added!.has(iter)) {\n          added!.add(iter)\n          yield iter\n        }\n        break\n      default:\n        yield iter\n    }\n  },\n)\narray['unique'].arity = 1\n\narray['intersects'] = mappedExecutor(\n  (args) => args,\n  (_, arr1, arr2) => {\n    // Intersects returns true if the two arrays have at least one element in common. Only\n    // primitives are supported; non-primitives are ignored.\n    if (arr1.type !== 'array' || arr2.type !== 'array') {\n      return NULL_VALUE\n    }\n\n    for (const v1 of arr1.data) {\n      for (const v2 of arr2.data) {\n        if (isEqual(fromJS(v1), fromJS(v2))) {\n          return TRUE_VALUE\n        }\n      }\n    }\n\n    return FALSE_VALUE\n  },\n)\narray['intersects'].arity = 2\n\nexport default array\n","import type {FunctionSet} from '.'\nimport {DateTime, fromDateTime} from '../../values'\nimport {constantExecutor} from '../evaluate'\n\nconst dateTime: FunctionSet = {}\ndateTime['now'] = constantExecutor((_, scope) =>\n  fromDateTime(new DateTime(scope.context.timestamp)),\n)\ndateTime['now'].arity = 0\n\nexport default dateTime\n","import {fromJS, type Value} from '../values'\nimport {deepEqual} from './equality'\nimport type {KeyPath} from './types'\n\nexport async function valueAtPath(arg: Value, keyPath: KeyPath): Promise<any> {\n  function tryAccessor(arg: any, accessor: string | number): any | undefined {\n    try {\n      return arg[accessor]\n    } catch {\n      // ignore the error\n      return undefined\n    }\n  }\n\n  let current = await arg.get()\n  for (const part of keyPath) {\n    current = tryAccessor(current, part)\n    if (!current) break\n  }\n  return current\n}\n\nexport function startsWith(keyPath: KeyPath, prefix: KeyPath): boolean {\n  return prefix.every((item, index) => keyPath[index] === item)\n}\n\nexport async function* diffKeyPaths(before: Value, after: Value): AsyncGenerator<KeyPath> {\n  // a queue of paths to investigate for differences\n  const currPaths: KeyPath[] = [[]]\n  while (currPaths.length > 0) {\n    const currPath: KeyPath = currPaths.shift() || []\n    const b = fromJS(await valueAtPath(before, currPath))\n    const a = fromJS(await valueAtPath(after, currPath))\n\n    if (a.type !== b.type) {\n      yield currPath\n    } else if (\n      (a.type === 'string' && b.type === 'string') ||\n      (a.type === 'boolean' && b.type === 'boolean') ||\n      (a.type === 'null' && b.type === 'null') ||\n      (a.type === 'number' && b.type === 'number')\n    ) {\n      if (a.data !== b.data) yield currPath\n    } else if (a.type === 'datetime' && b.type === 'datetime') {\n      if (!a.data.equals(b.data)) yield currPath\n    } else if (a.type === 'object' && b.type === 'object') {\n      if (!deepEqual(a.data, b.data)) {\n        const aKeys = Object.keys(a.data)\n        const bKeys = Object.keys(b.data)\n        const keys = new Set(aKeys.concat(bKeys))\n        keys.forEach((key) => {\n          currPaths.push([...currPath, key])\n        })\n      }\n    } else if (a.type === 'array' && b.type === 'array') {\n      if (a.data.length !== b.data.length) {\n        yield currPath\n      } else if (!deepEqual(a.data, b.data)) {\n        for (let i = 0; i < b.data.length; i++) {\n          currPaths.push([...currPath, i])\n        }\n      }\n    } else if (a.type === 'stream' && b.type === 'stream') {\n      const arrayA = await a.get()\n      const arrayB = await b.get()\n\n      if (arrayA.length !== arrayB.length) {\n        yield currPath\n      } else if (!deepEqual(arrayA, arrayB)) {\n        for (let i = 0; i < arrayB.length; i++) {\n          currPaths.push([...currPath, i])\n        }\n      }\n    }\n  }\n}\n","import type {ExprNode, FilterNode, SelectorNode} from '../nodeTypes'\nimport {fromJS, type Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {valueAtPath} from './keyPath'\nimport type {Scope} from './scope'\nimport type {KeyPath} from './types'\n\nexport async function evaluateSelector(\n  node: SelectorNode,\n  value: Value,\n  scope: Scope,\n): Promise<KeyPath[]> {\n  switch (node.type) {\n    case 'Group':\n      return await evaluateSelector(node.base, value, scope)\n    case 'Tuple':\n      const tuplePaths: Array<KeyPath> = []\n      for (const member of node.members) {\n        const memberPaths = await evaluateSelector(member, value, scope)\n        tuplePaths.push(...memberPaths)\n      }\n      return tuplePaths\n    case 'AccessAttribute':\n      if (node.base) {\n        const accessPaths = await evaluateSelector(node.base, value, scope)\n        return accessPaths.map((path) => [...path, node.name])\n      }\n\n      return [[node.name]]\n    case 'ArrayCoerce': {\n      const paths = await evaluateSelector(node.base, value, scope)\n\n      const arrayPaths: KeyPath[] = []\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath)\n\n        if (Array.isArray(innerValue)) {\n          for (let i = 0; i < innerValue.length; i++) {\n            arrayPaths.push([...keyPath, i])\n          }\n        }\n      }\n\n      return arrayPaths\n    }\n    case 'Filter': {\n      const paths = await evaluateSelector(node.base, value, scope)\n\n      // create a special filter to use the current value by making the base `this`\n      const filter: FilterNode = {\n        ...node,\n        base: {type: 'This'},\n      }\n\n      const arrayPaths: KeyPath[] = []\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath)\n        if (Array.isArray(innerValue)) {\n          for (let i = 0; i < innerValue.length; i++) {\n            const item = innerValue[i]\n            const nestedScope = scope.createNested(fromJS([item]))\n            const result = await evaluate(filter, nestedScope)\n            const matched = await result.get()\n            if (matched.length > 0) arrayPaths.push([...keyPath, i])\n          }\n        }\n      }\n\n      return arrayPaths\n    }\n    case 'SelectorFuncCall': {\n      return anywhere(node.arg, scope.createHidden(value))\n    }\n    case 'SelectorNested': {\n      const {base, nested: expr} = node\n\n      const paths = await evaluateSelector(base, value, scope)\n      const nestedPaths: KeyPath[] = []\n      for (const keyPath of paths) {\n        const innerValue = await valueAtPath(value, keyPath)\n\n        switch (expr.type) {\n          case 'AccessAttribute':\n          case 'ArrayCoerce':\n          case 'Filter':\n            const accessPaths = await evaluateSelector(expr, fromJS(innerValue), scope)\n            for (let i = 0; i < accessPaths.length; i++) {\n              nestedPaths.push([...keyPath, ...accessPaths[i]])\n            }\n            break\n\n          case 'Group':\n            const innerResult = await evaluateSelector(expr.base, fromJS(innerValue), scope)\n            for (const innerKeyPath of innerResult) {\n              nestedPaths.push([...keyPath, ...innerKeyPath])\n            }\n            break\n\n          case 'Tuple':\n            for (const inner of expr.members) {\n              const innerResult = await evaluateSelector(inner, fromJS(innerValue), scope)\n              for (const innerKeyPath of innerResult) {\n                nestedPaths.push([...keyPath, ...innerKeyPath])\n              }\n            }\n        }\n      }\n      return nestedPaths\n    }\n  }\n}\n\nasync function anywhere(expr: ExprNode, scope: Scope, base: KeyPath = []): Promise<KeyPath[]> {\n  const value = scope.value\n\n  const pathList: KeyPath[] = []\n  if (value.isArray()) {\n    const arr: any[] = await value.get()\n    for (let i = 0; i < arr.length; i++) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(arr[i])), [...base, i])\n      pathList.push(...subPaths)\n    }\n  } else if (value.type === 'object') {\n    const result = await evaluate(expr, scope)\n    if (result.type === 'boolean' && result.data === true) {\n      pathList.push(base)\n    }\n\n    for (const key of Object.keys(value.data)) {\n      const subPaths = await anywhere(expr, scope.createHidden(fromJS(value.data[key])), [\n        ...base,\n        key,\n      ])\n      pathList.push(...subPaths)\n    }\n  }\n\n  return pathList\n}\n","import type {FunctionSet} from '.'\nimport {isSelectorNode, type SelectorNode} from '../../nodeTypes'\nimport {FALSE_VALUE, TRUE_VALUE, type BooleanValue, type Value} from '../../values'\nimport {deepEqual} from '../equality'\nimport {asyncOnlyExecutor, executeAsync} from '../evaluate'\nimport {diffKeyPaths, startsWith, valueAtPath} from '../keyPath'\nimport type {Scope} from '../scope'\nimport {evaluateSelector} from '../selector'\n\nexport async function changedAny(\n  before: Value,\n  after: Value,\n  selector: SelectorNode,\n  scope: Scope,\n): Promise<BooleanValue> {\n  const beforeSelectorScope = scope.createHidden(before)\n  const beforePaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope,\n  )\n  const afterSelectorScope = scope.createHidden(after)\n  const afterPaths = await evaluateSelector(selector, afterSelectorScope.value, afterSelectorScope)\n  if (beforePaths.length !== afterPaths.length) {\n    return TRUE_VALUE\n  }\n\n  for (const path of beforePaths) {\n    for (let i = 0; i < path.length; i++) {\n      if (typeof path[i] === 'number') {\n        const slice = path.slice(0, i)\n        const beforeArr = await valueAtPath(before, slice)\n        const afterArr = await valueAtPath(after, slice)\n\n        if (\n          !Array.isArray(beforeArr) ||\n          !Array.isArray(afterArr) ||\n          beforeArr.length !== afterArr.length\n        ) {\n          return TRUE_VALUE\n        }\n      }\n    }\n\n    const beforeValue = await valueAtPath(before, path)\n    const afterValue = await valueAtPath(after, path)\n\n    if (!deepEqual(beforeValue, afterValue)) {\n      return TRUE_VALUE\n    }\n  }\n\n  return FALSE_VALUE\n}\n\nexport async function changedOnly(\n  before: Value,\n  after: Value,\n  selector: SelectorNode,\n  scope: Scope,\n): Promise<BooleanValue> {\n  const beforeSelectorScope = scope.createHidden(before)\n  const selectedPaths = await evaluateSelector(\n    selector,\n    beforeSelectorScope.value,\n    beforeSelectorScope,\n  )\n\n  for await (const diffPath of diffKeyPaths(before, after)) {\n    let found = false\n    for (const selectedPath of selectedPaths) {\n      // it matches if the diff path starts with the selected path\n      const match = startsWith(diffPath, selectedPath)\n      if (match) {\n        found = true\n        break\n      }\n    }\n    if (!found) {\n      return FALSE_VALUE\n    }\n  }\n\n  return TRUE_VALUE\n}\n\nconst diff: FunctionSet = {}\ndiff['changedAny'] = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0]\n  const rhs = args[1]\n  const selector = args[2]\n  if (!isSelectorNode(selector)) throw new Error('changedAny third argument must be a selector')\n\n  const before = await executeAsync(lhs, scope)\n  const after = await executeAsync(rhs, scope)\n\n  return changedAny(before, after, selector, scope)\n})\ndiff['changedAny'].arity = 3\n\ndiff['changedOnly'] = asyncOnlyExecutor(async (args, scope) => {\n  const lhs = args[0]\n  const rhs = args[1]\n  const selector = args[2]\n  if (!isSelectorNode(selector)) throw new Error('changedOnly third argument must be a selector')\n\n  const before = await executeAsync(lhs, scope)\n  const after = await executeAsync(rhs, scope)\n\n  return changedOnly(before, after, selector, scope)\n})\ndiff['changedOnly'].arity = 3\n\nexport default diff\n","import type {FunctionSet} from '.'\nimport {isSelectorNode} from '../../nodeTypes'\nimport {fromString, NULL_VALUE} from '../../values'\nimport {asyncOnlyExecutor, constantExecutor} from '../evaluate'\nimport {changedAny, changedOnly} from './diff'\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta['operation'] = constantExecutor((_, scope) => {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n})\n\ndelta['changedAny'] = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE\n  const after = scope.context.after || NULL_VALUE\n  const selector = args[0]\n  if (!isSelectorNode(selector)) throw new Error('changedAny first argument must be a selector')\n\n  return changedAny(before, after, selector, scope)\n})\ndelta['changedAny'].arity = 1\ndelta['changedAny'].mode = 'delta'\n\ndelta['changedOnly'] = asyncOnlyExecutor(async (args, scope) => {\n  const before = scope.context.before || NULL_VALUE\n  const after = scope.context.after || NULL_VALUE\n  const selector = args[0]\n  if (!isSelectorNode(selector)) throw new Error('changedOnly first argument must be a selector')\n\n  return changedOnly(before, after, selector, scope)\n})\ndelta['changedOnly'].arity = 1\ndelta['changedOnly'].mode = 'delta'\n\nexport default delta\n","import type {FunctionSet} from '.'\nimport {constantExecutor} from '../evaluate'\n\nconst documents: FunctionSet = {}\ndocuments['get'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\nexport default documents\n","import type {FunctionSet} from '.'\nimport {constantExecutor} from '../evaluate'\n\nconst geo: FunctionSet = {}\ngeo['latLng'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ngeo['contains'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ngeo['intersects'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ngeo['distance'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\n\nexport default geo\n","import type {FunctionSet} from '.'\nimport {FALSE_VALUE, fromArray, fromString, NULL_VALUE, TRUE_VALUE} from '../../values'\nimport {mappedExecutor} from '../evaluate'\n\nconst string: FunctionSet = {}\n\nstring['lower'] = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    if (value.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return fromString(value.data.toLowerCase())\n  },\n)\nstring['lower'].arity = 1\n\nstring['upper'] = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    if (value.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return fromString(value.data.toUpperCase())\n  },\n)\nstring['upper'].arity = 1\n\nstring['split'] = mappedExecutor(\n  (args) => args,\n  (_, str, sep) => {\n    if (str.type !== 'string') {\n      return NULL_VALUE\n    }\n    if (sep.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    if (str.data.length === 0) {\n      return fromArray([])\n    }\n    if (sep.data.length === 0) {\n      // This uses a Unicode codepoint splitting algorithm\n      return fromArray(Array.from(str.data))\n    }\n    return fromArray(str.data.split(sep.data))\n  },\n)\nstring['split'].arity = 2\n\nstring['startsWith'] = mappedExecutor(\n  (args) => args,\n  (_, str, prefix) => {\n    if (str.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    if (prefix.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n  },\n)\nstring['startsWith'].arity = 2\n\nexport default string\n","import type {FunctionSet} from '.'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  TRUE_VALUE,\n} from '../../values'\nimport {\n  arrayReducerExecutor,\n  constantExecutor,\n  executeAsync,\n  executeSync,\n  mappedExecutor,\n} from '../evaluate'\nimport string from './string'\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\n_global['anywhere'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\n\n_global['anywhere'].arity = 1\n\n_global['coalesce'] = {\n  async executeAsync(args, scope) {\n    for (const arg of args) {\n      const value = await executeAsync(arg, scope)\n      if (value.type !== 'null') {\n        return value\n      }\n    }\n    return NULL_VALUE\n  },\n\n  executeSync(args, scope) {\n    for (const arg of args) {\n      const value = executeSync(arg, scope)\n      if (value.type !== 'null') {\n        return value\n      }\n    }\n    return NULL_VALUE\n  },\n}\n\n_global['count'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => 0,\n  (_, count) => count + 1,\n  fromNumber,\n)\n_global['count'].arity = 1\n\n_global['dateTime'] = mappedExecutor(\n  (args) => args,\n  (_, val) => {\n    if (val.type === 'datetime') {\n      return val\n    }\n    if (val.type !== 'string') {\n      return NULL_VALUE\n    }\n    return DateTime.parseToValue(val.data)\n  },\n)\n_global['dateTime'].arity = 1\n\n_global['defined'] = mappedExecutor(\n  (args) => args,\n  (_, inner) => {\n    return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n  },\n)\n_global['defined'].arity = 1\n\n// eslint-disable-next-line require-await\n_global['identity'] = constantExecutor((_args, scope) => {\n  return fromString(scope.context.identity)\n})\n_global['identity'].arity = 0\n\n_global['length'] = mappedExecutor(\n  (args) => args,\n  (_, inner) => {\n    if (inner.type === 'string') {\n      return fromNumber(countUTF8(inner.data))\n    }\n\n    if (inner.type === 'array') {\n      return fromNumber(inner.data.length)\n    }\n\n    return NULL_VALUE\n  },\n)\n_global['length'].arity = 1\n\n_global['path'] = mappedExecutor(\n  (args) => args,\n  (_, inner) => {\n    if (inner.type !== 'string') {\n      return NULL_VALUE\n    }\n\n    return fromPath(new Path(inner.data))\n  },\n)\n_global['path'].arity = 1\n\n_global['string'] = mappedExecutor(\n  (args) => args,\n  (_, value) => {\n    switch (value.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        return fromString(`${value.data}`)\n      default:\n        return NULL_VALUE\n    }\n  },\n)\n_global['string'].arity = 1\n\n_global['references'] = mappedExecutor(\n  (args) => [{type: 'This'}, ...args],\n  (_, scopeValue, ...args) => {\n    const pathSet = new Set<string>()\n    for (const path of args) {\n      if (path.type === 'string') {\n        pathSet.add(path.data)\n      } else if (path.type === 'array') {\n        for (const elem of path.data) {\n          if (typeof elem === 'string') {\n            pathSet.add(elem)\n          }\n        }\n      }\n    }\n\n    if (pathSet.size === 0) {\n      return FALSE_VALUE\n    }\n\n    return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n  },\n)\n_global['references'].arity = (c) => c >= 1\n\n_global['round'] = mappedExecutor(\n  (args) => args,\n  (_, value, precValue) => {\n    if (value.type !== 'number') {\n      return NULL_VALUE\n    }\n\n    const num = value.data\n    let prec = 0\n\n    if (precValue) {\n      if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n        return NULL_VALUE\n      }\n      prec = precValue.data\n    }\n\n    if (prec === 0) {\n      if (num < 0) {\n        // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n        // The behavior we're interested in is to \"round half away from zero\".\n        return fromNumber(-Math.round(-num))\n      }\n      return fromNumber(Math.round(num))\n    }\n    return fromNumber(Number(num.toFixed(prec)))\n  },\n)\n_global['round'].arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global['now'] = constantExecutor((_args, scope) => {\n  return fromString(scope.context.timestamp.toISOString())\n})\n_global['now'].arity = 0\n\n// eslint-disable-next-line require-await\n_global['boost'] = constantExecutor(() => {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n})\n\n_global['boost'].arity = 2\n\n_global['lower'] = string['lower']\n_global['upper'] = string['upper']\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nexport default _global\n","import type {FunctionSet} from '.'\nimport {fromNumber, NULL_VALUE} from '../../values'\nimport {arrayReducerExecutor, STOP_ITERATOR} from '../evaluate'\n\nconst math: FunctionSet = {}\nmath['min'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => undefined as undefined | number,\n  (_, n, item) => {\n    if (item === null) return n\n    if (typeof item !== 'number') return STOP_ITERATOR\n    if (n === undefined || item < n) return item\n    return n\n  },\n  (n) => (n === undefined ? NULL_VALUE : fromNumber(n)),\n)\nmath['min'].arity = 1\n\nmath['max'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => undefined as undefined | number,\n  (_, n, item) => {\n    if (item === null) return n\n    if (typeof item !== 'number') return STOP_ITERATOR\n    if (n === undefined || item > n) return item\n    return n\n  },\n  (n) => (n === undefined ? NULL_VALUE : fromNumber(n)),\n)\nmath['max'].arity = 1\n\nmath['sum'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => 0,\n  (_, n, item) => {\n    if (item === null) return n\n    if (typeof item !== 'number') return STOP_ITERATOR\n    return n + item\n  },\n  fromNumber,\n)\nmath['sum'].arity = 1\n\nmath['avg'] = arrayReducerExecutor(\n  (args) => ({array: args[0]!}),\n  () => ({count: 0, sum: 0}),\n  (_, {count, sum}, item) => {\n    if (item === null) return {count, sum}\n    if (typeof item !== 'number') return STOP_ITERATOR\n    return {count: count + 1, sum: sum + item}\n  },\n  ({count, sum}) => (count === 0 ? NULL_VALUE : fromNumber(sum / count)),\n)\nmath['avg'].arity = 1\n\nexport default math\n","import type {AnyStaticValue} from '../values'\n\nexport function portableTextContent(value: AnyStaticValue): string | null {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.type === 'array') {\n    const texts = arrayText(value.data)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nfunction arrayText(value: unknown[], result: string[] = []): string[] {\n  for (const block of value) {\n    if (Array.isArray(block)) {\n      arrayText(block, result)\n    } else if (typeof block === 'object' && block) {\n      const text = blockText(block as Record<string, unknown>)\n      if (text !== null) result.push(text)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj['_type'] !== 'string') return null\n  const children = obj['children']\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n","import type {FunctionSet} from '.'\nimport {fromString, NULL_VALUE} from '../../values'\nimport {portableTextContent} from '../pt'\nimport {mappedExecutor} from '../evaluate'\n\nconst pt: FunctionSet = {}\npt['text'] = mappedExecutor(\n  (args) => args,\n  function (_, value) {\n    const text = portableTextContent(value)\n\n    if (text === null) {\n      return NULL_VALUE\n    }\n\n    return fromString(text)\n  },\n)\n\npt['text'].arity = 1\n\nexport default pt\n","import type {FunctionSet} from '.'\nimport {arrayExecutor} from '../evaluate'\n\nconst releases: FunctionSet = {}\n\n// eslint-disable-next-line require-await\nreleases['all'] = arrayExecutor(\n  () => ({array: {type: 'Everything'}}),\n  function* (_, value) {\n    if (\n      typeof value === 'object' &&\n      value &&\n      '_type' in value &&\n      value._type === 'system.release'\n    ) {\n      yield value\n    }\n  },\n)\nreleases['all'].arity = 0\n\nexport default releases\n","import type {FunctionSet} from '.'\nimport {FALSE_VALUE, fromString, NULL_VALUE, TRUE_VALUE} from '../../values'\nimport {constantExecutor, mappedExecutor} from '../evaluate'\n\nconst sanity: FunctionSet = {}\nsanity['projectId'] = constantExecutor((_, scope) => {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n})\nsanity['dataset'] = constantExecutor((_, scope) => {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n})\n\n// eslint-disable-next-line require-await\nsanity['versionOf'] = mappedExecutor(\n  ([value]) => [value!, {type: 'This'}],\n  (_, value, val) => {\n    if (value.type !== 'string') return NULL_VALUE\n    const baseId = value.data\n\n    if (val.type !== 'object') return NULL_VALUE\n    if (typeof val.data['_id'] !== 'string') return NULL_VALUE\n\n    // published document\n    if (val.data['_id'] === baseId) return TRUE_VALUE\n\n    const components = val.data['_id'].split('.')\n\n    // draft document\n    if (\n      components.length >= 2 &&\n      components[0] === 'drafts' &&\n      components.slice(1).join('.') === baseId\n    ) {\n      return TRUE_VALUE\n    }\n\n    // version document\n    if (\n      components.length >= 3 &&\n      components[0] === 'versions' &&\n      components.slice(2).join('.') === baseId\n    ) {\n      return TRUE_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n)\nsanity['versionOf'].arity = 1\n\n// eslint-disable-next-line require-await\nsanity['partOfRelease'] = mappedExecutor(\n  (args) => [args[0]!, {type: 'This'}],\n  (_, value, val) => {\n    if (value.type !== 'string') return NULL_VALUE\n    const baseId = value.data\n\n    if (val.type !== 'object') return NULL_VALUE\n\n    if (typeof val.data['_id'] !== 'string') return NULL_VALUE\n\n    const components = val.data['_id'].split('.')\n    if (components.length >= 3 && components[0] === 'versions' && components[1] === baseId) {\n      return TRUE_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n)\nsanity['partOfRelease'].arity = 1\n\nexport default sanity\n","import type {FunctionSet} from '.'\nimport {constantExecutor} from '../evaluate'\n\n/**\n * Text query function - no-op implementation.\n *\n * groq-js has no search engine, but we provide this no-op implementation\n * to avoid throwing errors when parsing queries that use text::query().\n */\nconst text: FunctionSet = {}\ntext['query'] = constantExecutor(() => {\n  throw new Error('not implemented')\n})\ntext['query'].arity = 1\n\nexport default text\n","import type {ExprNode} from '../nodeTypes'\nimport type {Value} from '../values'\nimport {executeAsync, executeSync} from './evaluate'\nimport {\n  gatherText,\n  matchPatternRegex,\n  matchTokenize,\n  type GatheredText,\n  type Token,\n} from './matching'\nimport {Scope} from './scope'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScoreAsync(node: ExprNode, scope: Scope): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScoreAsync(node.left, node.right, scope)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScoreAsync(node.args[0]!, scope)\n    const boost = await executeAsync(node.args[1]!, scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScoreAsync(node.left, scope)\n      const rightScore = await evaluateScoreAsync(node.right, scope)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScoreAsync(node.left, scope)\n      const rightScore = await evaluateScoreAsync(node.right, scope)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await executeAsync(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nexport function evaluateScoreSync(node: ExprNode, scope: Scope): number {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScoreSync(node.left, node.right, scope)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = evaluateScoreSync(node.args[0]!, scope)\n    const boost = executeSync(node.args[1]!, scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = evaluateScoreSync(node.left, scope)\n      const rightScore = evaluateScoreSync(node.right, scope)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = evaluateScoreSync(node.left, scope)\n      const rightScore = evaluateScoreSync(node.right, scope)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = executeSync(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nfunction evaluateMatchScoreSync(left: ExprNode, right: ExprNode, scope: Scope): number {\n  const text = executeSync(left, scope)\n  const pattern = executeSync(right, scope)\n  const result = processMatchScore(text, pattern)\n  if (typeof result === 'number') return result\n  throw new Error('Found synchronous value in match()')\n}\n\nasync function evaluateMatchScoreAsync(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n): Promise<number> {\n  const text = await executeAsync(left, scope)\n  const pattern = await executeAsync(right, scope)\n  return processMatchScore(text, pattern)\n}\n\nfunction processMatchScore(text: Value, pattern: Value): Promise<number> | number {\n  const tokens = gatherText(text, (part) => matchTokenize(part))\n  const terms = gatherText(pattern, (part) => matchPatternRegex(part))\n\n  const process = (tokens: GatheredText<Token>, terms: GatheredText<RegExp>): number => {\n    if (!terms.success) return 0\n\n    if (tokens.parts.length === 0 || terms.parts.length === 0) {\n      return 0\n    }\n\n    let score = 0\n\n    for (const re of terms.parts) {\n      const freq = tokens.parts.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n      score += (freq * (BM25k + 1)) / (freq + BM25k)\n    }\n\n    return score\n  }\n\n  if ('then' in tokens || 'then' in terms) {\n    return (async () => process(await tokens, await terms))()\n  }\n\n  return process(tokens, terms)\n}\n","import type {GroqPipeFunction, WithOptions} from '.'\nimport type {ExprNode} from '../../nodeTypes'\nimport {fromArray, fromJS, getType} from '../../values'\nimport {executeAsync, executeSync} from '../evaluate'\nimport {totalCompare} from '../ordering'\nimport {evaluateScoreAsync, evaluateScoreSync} from '../scoring'\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\ntype Direction = 'asc' | 'desc'\ntype AuxItem = [unknown, number, ...unknown[]]\n\nfunction extractOrderArgs(args: ExprNode[]): {mappers: ExprNode[]; directions: Direction[]} {\n  const mappers = []\n  const directions: Direction[] = []\n\n  for (let mapper of args) {\n    let direction: Direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n  }\n  return {mappers, directions}\n}\n\nfunction sortArray(aux: AuxItem[], directions: Direction[]): unknown[] {\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < directions.length; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return aux.map((v) => v[0])\n}\n\nconst pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions['order'] = {\n  executeSync({base, args}, scope) {\n    const {mappers, directions} = extractOrderArgs(args)\n    const aux: AuxItem[] = []\n\n    let idx = 0\n    const n = directions.length\n\n    for (const value of base.data) {\n      const newScope = scope.createNested(fromJS(value))\n      const tuple: AuxItem = [value, idx]\n      for (let i = 0; i < n; i++) {\n        const result = executeSync(mappers[i]!, newScope)\n        tuple.push(result.data)\n      }\n      aux.push(tuple)\n      idx++\n    }\n\n    return fromArray(sortArray(aux, directions))\n  },\n\n  async executeAsync({base, args}, scope) {\n    const {mappers, directions} = extractOrderArgs(args)\n    const aux: AuxItem[] = []\n\n    let idx = 0\n    const n = directions.length\n\n    for await (const value of base) {\n      const newScope = scope.createNested(value)\n      const tuple: AuxItem = [await value.get(), idx]\n      for (let i = 0; i < n; i++) {\n        const result = await executeAsync(mappers[i]!, newScope)\n        tuple.push(await result.get())\n      }\n      aux.push(tuple)\n      idx++\n    }\n\n    return fromArray(sortArray(aux, directions))\n  },\n}\npipeFunctions['order'].arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\n// eslint-disable-next-line require-await\npipeFunctions['score'] = {\n  async executeAsync({base, args}, scope) {\n    // Anything that isn't an object should be sorted first.\n    const unknown: Array<any> = []\n    const scored: Array<ObjectWithScore> = []\n\n    for await (const value of base) {\n      if (value.type !== 'object') {\n        unknown.push(await value.get())\n        continue\n      }\n\n      const newScope = scope.createNested(value)\n      let valueScore = typeof value.data['_score'] === 'number' ? value.data['_score'] : 0\n\n      for (const arg of args) {\n        valueScore += await evaluateScoreAsync(arg, newScope)\n      }\n\n      const newObject = Object.assign({}, value.data, {_score: valueScore})\n      scored.push(newObject)\n    }\n\n    scored.sort((a, b) => b._score - a._score)\n    return fromJS(scored)\n  },\n  executeSync({base, args}, scope) {\n    // Anything that isn't an object should be sorted first.\n    const unknown: Array<any> = []\n    const scored: Array<ObjectWithScore> = []\n\n    for (const value of base.data) {\n      if (getType(value) !== 'object') {\n        unknown.push(value)\n        continue\n      }\n\n      const valueObj = value as Record<string, unknown>\n\n      const newScope = scope.createNested(fromJS(value))\n      let valueScore = typeof valueObj['_score'] === 'number' ? valueObj['_score'] : 0\n\n      for (const arg of args) {\n        valueScore += evaluateScoreSync(arg, newScope)\n      }\n\n      const newObject = Object.assign({}, valueObj, {_score: valueScore})\n      scored.push(newObject)\n    }\n\n    scored.sort((a, b) => b._score - a._score)\n    return fromArray(scored)\n  },\n}\npipeFunctions['score'].arity = (count) => count >= 1\n\nexport default pipeFunctions\n","import {type ExprNode} from '../../nodeTypes'\nimport {StreamValue, type ArrayValue} from '../../values'\nimport type {Executor} from '../types'\nimport array from './array'\nimport dateTime from './dateTime'\nimport delta from './delta'\nimport diff from './diff'\nimport documents from './documents'\nimport geo from './geo'\nimport _global from './global'\nimport math from './math'\nimport pt from './pt'\nimport releases from './releases'\nimport sanity from './sanity'\nimport string from './string'\nimport text from './text'\n\nexport {default as pipeFunctions} from './pipeFunctions'\n\n/** @public */\nexport type GroqFunctionArg = ExprNode\n\n/** @internal */\nexport type WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\n/** @public */\nexport type GroqFunction = Executor<GroqFunctionArg[]>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\nexport type GroqPipeFunction = Executor<\n  {base: ArrayValue | StreamValue; args: ExprNode[]},\n  {base: ArrayValue; args: ExprNode[]}\n>\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n  dateTime,\n  releases,\n  text,\n  geo,\n  documents,\n}\n","import type {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n","'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', message: 'Unexpected end of query', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let result = parseGroupOrTuple(str, pos)\n      if (result.type === 'error') return result\n\n      pos = result.position\n      marks = result.marks\n\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', message: 'Expected \"]\" after array expression', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', message: 'Exponent must be a number', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', message: 'Expected expression', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    } // ignore if type === 'error'\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', message: 'Expected identifier', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // desc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')')\n                return {type: 'error', message: 'Expected \")\" in group', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseGroupOrTuple(str, pos) {\n  const startPos = pos\n  let marks\n  let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n  if (rhs.type === 'error') return rhs\n  pos = skipWS(str, rhs.position)\n  switch (str[pos]) {\n    case ',': {\n      // Tuples\n      marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n      pos = skipWS(str, pos + 1)\n      while (true) {\n        rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        marks.push(...rhs.marks)\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ',') break\n        pos = skipWS(str, pos + 1)\n      }\n      if (str[pos] !== ')')\n        return {type: 'error', message: 'Expected \")\" after tuple expression', position: pos}\n      pos++\n      marks.push({name: 'tuple_end', position: pos})\n      break\n    }\n    case ')': {\n      pos++\n      marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n      break\n    }\n    default:\n      return {type: 'error', message: `Unexpected character \"${str[pos]}\"`, position: pos}\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n\n      // allow tuples/groups in a traversal for selectors\n      if (str[pos] === '(') {\n        return parseGroupOrTuple(str, pos)\n      }\n\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', message: 'Expected identifier after \".\"', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>')\n        return {type: 'error', message: 'Expected \">\" in reference', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos},\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']')\n          return {type: 'error', message: 'Expected \"]\" after array expression', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']')\n        return {type: 'error', message: 'Expected \"]\" after array expression', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', message: 'Unexpected character in traversal', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', message: 'Expected function name', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(')\n      return {type: 'error', message: 'Expected \"(\" after function name', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', message: 'Expected \")\" after function arguments', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', message: 'Expected \"}\" after object', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', message: 'Unexpected end of query', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n","/* eslint-disable camelcase */\nimport type {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null,\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n","/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {type GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {MarkProcessor, type MarkVisitor} from './markProcessor'\nimport {\n  isSelectorNested,\n  type ArrayElementNode,\n  type ExprNode,\n  type FuncCallNode,\n  type ObjectAttributeNode,\n  type ObjectSplatNode,\n  type OpCall,\n  type ParentNode,\n  type SelectNode,\n  type SelectorNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  type TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport type {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  'b': '\\b',\n  'f': '\\f',\n  'n': '\\n',\n  'r': '\\r',\n  't': '\\t',\n}\n\ntype TraverseFunc = (right: TraversalResult | null) => TraversalResult\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public override name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<TraverseFunc> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        args.push(p.process(SELECTOR_BUILDER))\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      namespace,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair() {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc() {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc() {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<TraverseFunc> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right,\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs,\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right,\n      )\n  },\n\n  array_postfix() {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<SelectorNode> = {\n  group(p) {\n    return p.process(SELECTOR_BUILDER)\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    let node: SelectorNode = p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      if (p.getMark().name === 'array_postfix') {\n        p.shift()\n\n        node = {type: 'ArrayCoerce', base: node}\n      } else if (p.getMark().name === 'square_bracket') {\n        p.shift()\n\n        const expr = p.process(EXPR_BUILDER)\n\n        const value = tryConstantEvaluate(expr)\n        if (value && value.type === 'number') {\n          throw new Error('Invalid array access expression')\n        } else if (value && value.type === 'string') {\n          node = {type: 'AccessAttribute', base: node, name: value.data}\n        } else {\n          node = {type: 'Filter', base: node, expr}\n        }\n      } else if (p.getMark().name === 'attr_access') {\n        p.shift()\n        const name = p.processString()\n        node = {type: 'AccessAttribute', base: node, name}\n      } else if (p.getMark().name === 'tuple' || p.getMark().name === 'group') {\n        const selector = p.process(SELECTOR_BUILDER)\n        if (!isSelectorNested(selector))\n          throw new Error(`Unexpected result parsing nested selector: ${selector.type}`)\n        node = {type: 'SelectorNested', base: node, nested: selector}\n      } else {\n        throw new Error('Invalid selector syntax')\n      }\n    }\n    p.shift()\n    return node\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n    return {type: 'AccessAttribute', name}\n  },\n\n  attr_access() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  neg() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    const selectors: Array<SelectorNode> = []\n    while (p.getMark().name !== 'tuple_end') {\n      selectors.push(p.process(SELECTOR_BUILDER))\n    }\n    p.shift()\n\n    return {type: 'Tuple', members: selectors}\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER['func_call'](p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) {\n      return {\n        type: 'SelectorFuncCall',\n        name: 'anywhere',\n        arg: func.args[0],\n      }\n    }\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param() {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'PipeFuncCall' ||\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce' ||\n    node.type === 'Group'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`,\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public override name = 'GroqSyntaxError'\n\n  constructor(position: number, detail: string) {\n    super(`Syntax error in GROQ query at position ${position}${detail ? ': ' + detail : ''}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position, result.message)\n  }\n  const processor = new MarkProcessor(input, result.marks, options)\n  return processor.process(EXPR_BUILDER)\n}\n","import type {TypeNode} from './types'\n\nconst {compare} = new Intl.Collator('en')\nfunction typeNodesSorter(a: TypeNode, b: TypeNode): number {\n  if (a.type === 'null') {\n    return 1\n  }\n  return compare(hashField(a), hashField(b))\n}\n\nconst hashCache = new WeakMap<TypeNode, string>()\n\nexport function hashField(field: TypeNode): string {\n  if (hashCache.has(field)) {\n    return hashCache.get(field)!\n  }\n  const hash = calculateFieldHash(field)\n  hashCache.set(field, hash)\n  return hash\n}\n\nfunction calculateFieldHash(field: TypeNode): string {\n  switch (field.type) {\n    case 'string':\n    case 'number':\n    case 'boolean': {\n      if (field.value !== undefined) {\n        return `${field.type}(${field.value})`\n      }\n\n      return `${field.type}`\n    }\n\n    case 'null':\n    case 'unknown': {\n      return field.type\n    }\n\n    case 'array': {\n      return `${field.type}(${hashField(field.of)})`\n    }\n\n    case 'object': {\n      const attributes = Object.entries(field.attributes)\n      attributes.sort(([a], [b]) => compare(a, b)) // sort them by name\n      return `${field.type}:(${attributes\n        .map(\n          ([key, value]) =>\n            `${key}:${hashField(value.value)}(${value.optional ? 'optional' : 'non-optional'})`,\n        )\n        .join(',')}):ref-${field.dereferencesTo}:${field.rest ? hashField(field.rest) : 'no-rest'}`\n    }\n\n    case 'union': {\n      const sorted = [...field.of]\n      sorted.sort(typeNodesSorter)\n      return `${field.type}(${sorted.map(hashField).join(',')})`\n    }\n\n    case 'inline': {\n      return `${field.type}(${field.name})`\n    }\n\n    default: {\n      // @ts-expect-error - we should never reach this, make sure we cover all type cases\n      return field.type\n    }\n  }\n}\n\nexport function removeDuplicateTypeNodes(typeNodes: TypeNode[]): TypeNode[] {\n  const seenTypes = new Set<string>()\n  const newTypeNodes = []\n\n  const sortedTypeNodes = [...typeNodes]\n  sortedTypeNodes.sort(typeNodesSorter)\n\n  for (const typeNode of sortedTypeNodes) {\n    const hash = hashField(typeNode)\n    if (hash === null) {\n      newTypeNodes.push(typeNode)\n      continue\n    }\n    if (seenTypes.has(hash)) {\n      continue\n    }\n\n    seenTypes.add(hash)\n    newTypeNodes.push(typeNode)\n  }\n\n  return newTypeNodes\n}\n\nexport function optimizeUnions(field: TypeNode): TypeNode {\n  if (field.type === 'union') {\n    if (field.of.length === 0) {\n      return field\n    }\n\n    field.of = removeDuplicateTypeNodes(field.of)\n\n    if (field.of.length === 1) {\n      return optimizeUnions(field.of[0])\n    }\n\n    // flatten union\n    for (let idx = 0; field.of.length > idx; idx++) {\n      const subField = field.of[idx]\n      if (subField.type === 'union') {\n        field.of.splice(idx, 1, ...subField.of)\n        idx--\n        continue\n      }\n\n      field.of[idx] = optimizeUnions(subField)\n    }\n\n    field.of.sort((a, b) => {\n      if (a.type === 'null') {\n        return 1\n      }\n      return compare(hashField(a), hashField(b))\n    })\n\n    return field\n  }\n\n  if (field.type === 'array') {\n    field.of = optimizeUnions(field.of)\n    return field\n  }\n\n  if (field.type === 'object') {\n    for (const idx in field.attributes) {\n      if (!Object.hasOwn(field.attributes, idx)) {\n        continue\n      }\n\n      field.attributes[idx].value = optimizeUnions(field.attributes[idx].value)\n    }\n    return field\n  }\n\n  return field\n}\n","import type {ExprNode} from '../nodeTypes'\nimport {optimizeUnions} from './optimizations'\nimport type {Scope} from './scope'\nimport type {\n  ArrayTypeNode,\n  BooleanTypeNode,\n  InlineTypeNode,\n  NullTypeNode,\n  NumberTypeNode,\n  ObjectAttribute,\n  ObjectTypeNode,\n  StringTypeNode,\n  TypeNode,\n  UnionTypeNode,\n  UnknownTypeNode,\n} from './types'\n\n/**\n * createReferenceTypeNode creates a ObjectTypeNode representing a reference type\n * it adds required attributes for a reference type.\n * @param name - The name of the reference type\n * @param inArray - Whether the reference is in an array\n * @returns A ObjectTypeNode representing a reference type\n * @internal\n */\nexport function createReferenceTypeNode(name: string, inArray: boolean = false): ObjectTypeNode {\n  const attributes: Record<string, ObjectAttribute> = {\n    _ref: {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n      },\n    },\n    _type: {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n        value: 'reference',\n      },\n    },\n    _weak: {\n      type: 'objectAttribute',\n      value: {\n        type: 'boolean',\n      },\n      optional: true,\n    },\n  }\n\n  if (inArray) {\n    attributes['_key'] = {\n      type: 'objectAttribute',\n      value: {\n        type: 'string',\n      },\n    } satisfies ObjectAttribute\n  }\n\n  return {\n    type: 'object',\n    attributes,\n    dereferencesTo: name,\n  } satisfies ObjectTypeNode\n}\n\nexport function nullUnion(node: TypeNode): UnionTypeNode {\n  if (node.type === 'union') {\n    return unionOf(...node.of, {type: 'null'})\n  }\n\n  return unionOf(node, {type: 'null'})\n}\n\nexport function unionOf(...nodes: TypeNode[]): UnionTypeNode {\n  return {\n    type: 'union',\n    of: nodes,\n  } satisfies UnionTypeNode\n}\n\nexport type ConcreteTypeNode =\n  | BooleanTypeNode\n  | NullTypeNode\n  | NumberTypeNode\n  | StringTypeNode\n  | ArrayTypeNode\n  | ObjectTypeNode\n\nexport function resolveInline(node: TypeNode, scope: Scope): Exclude<TypeNode, InlineTypeNode> {\n  if (node.type === 'inline') {\n    const resolvedInline = scope.context.lookupTypeDeclaration(node)\n    return resolveInline(resolvedInline, scope)\n  }\n\n  return node\n}\n\n/**\n * mapNode extracts either a _concrete type_ OR an _unknown type_ from a type node, applies the mapping\n * function to it and returns. Most notably, this will work through unions\n * (applying the mapping function for each variant) and inline (resolving the\n * reference).\n **/\nexport function mapNode<T extends TypeNode = TypeNode>(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ConcreteTypeNode | UnknownTypeNode) => T,\n  mergeUnions: (nodes: TypeNode[]) => TypeNode = (nodes) =>\n    optimizeUnions({type: 'union', of: nodes}),\n): TypeNode {\n  switch (node.type) {\n    case 'boolean':\n    case 'array':\n    case 'null':\n    case 'object':\n    case 'string':\n    case 'number':\n    case 'unknown':\n      return mapper(node)\n    case 'union':\n      return mergeUnions(node.of.map((inner) => mapNode(inner, scope, mapper), mergeUnions))\n    case 'inline': {\n      const resolvedInline = resolveInline(node, scope)\n      return mapNode(resolvedInline, scope, mapper, mergeUnions)\n    }\n    default:\n      // @ts-expect-error - all types should be handled\n      throw new Error(`Unknown type: ${node.type}`)\n  }\n}\n\nexport function isFuncCall(node: ExprNode, name: string): boolean {\n  if (node.type === 'Group') {\n    return isFuncCall(node.base, name)\n  }\n\n  return node.type === 'FuncCall' && `${node.namespace}::${node.name}` === name\n}\n\nexport function createGeoJson(type: 'Point' | 'LineString' | 'Polygon' = 'Point'): ObjectTypeNode {\n  let coordinateAttribute: ArrayTypeNode = {\n    type: 'array',\n    of: {\n      type: 'number',\n    },\n  }\n  if (type === 'LineString') {\n    coordinateAttribute = {\n      type: 'array',\n      of: {\n        type: 'array',\n        of: {\n          type: 'number',\n        },\n      },\n    } satisfies ArrayTypeNode\n  }\n  if (type === 'Polygon') {\n    coordinateAttribute = {\n      type: 'array',\n      of: {\n        type: 'array',\n        of: {\n          type: 'array',\n          of: {\n            type: 'number',\n          },\n        },\n      },\n    }\n  }\n  return {\n    type: 'object',\n    attributes: {\n      type: {\n        type: 'objectAttribute',\n        value: {\n          type: 'string',\n          value: type,\n        },\n      },\n      coordinates: {\n        type: 'objectAttribute',\n        value: coordinateAttribute,\n      },\n    },\n  } satisfies ObjectTypeNode\n}\n","import type {Scope} from './scope'\nimport {nullUnion, resolveInline} from './typeHelpers'\nimport type {TypeNode} from './types'\n\ntype BooleanInterpretation = {\n  canBeTrue: boolean\n  canBeFalse: boolean\n  canBeNull: boolean\n}\n\n/**\n * booleanValue takes a TypeNode and returns a BooleanInterpretation.\n * BooleanInterpretation is a matrix of three booleans:\n * - canBeTrue: whether the TypeNode can resolve to true\n * - canBeFalse: whether the TypeNode can resolve to false\n * - canBeNull: whether the TypeNode can resolve to null\n * This is a helper method intended to determine the possible values of a boolean expression.\n * When resolving a boolean expression, we might not be able to determine the exact value of the expression,\n * but we can determine the possible values of the expression, Multiple values can be true at the same time.\n *\n * @param node - The TypeNode to evaluate\n * @returns BooleanInterpretation\n * @internal\n */\nexport function booleanValue(node: TypeNode, scope: Scope): BooleanInterpretation {\n  switch (node.type) {\n    case 'unknown': {\n      return {canBeTrue: true, canBeFalse: true, canBeNull: true}\n    }\n    case 'boolean': {\n      if (node.value === true) {\n        return {canBeTrue: true, canBeFalse: false, canBeNull: false}\n      }\n      if (node.value === false) {\n        return {canBeTrue: false, canBeFalse: true, canBeNull: false}\n      }\n\n      return {canBeTrue: true, canBeFalse: true, canBeNull: false}\n    }\n    case 'union': {\n      const value = {canBeTrue: false, canBeFalse: false, canBeNull: false}\n      for (const sub of node.of) {\n        const match = booleanValue(sub, scope)\n        if (match.canBeNull) {\n          value.canBeNull = true\n        }\n        if (match.canBeTrue) {\n          value.canBeTrue = true\n        }\n        if (match.canBeFalse) {\n          value.canBeFalse = true\n        }\n      }\n      return value\n    }\n    case 'inline': {\n      const resolved = resolveInline(node, scope)\n      return booleanValue(resolved, scope)\n    }\n    case 'null':\n    case 'string':\n    case 'number':\n    case 'object':\n    case 'array': {\n      return {canBeTrue: false, canBeFalse: false, canBeNull: true}\n    }\n    default: {\n      // @ts-expect-error - we should have handled all cases\n      throw new Error(`unknown node type ${node.type}`)\n    }\n  }\n}\n\nexport function booleanOr(\n  left: BooleanInterpretation,\n  right: BooleanInterpretation,\n): BooleanInterpretation {\n  // If either side can only be true, the expression can only be true, so we short-circuit\n  if (left.canBeTrue && !left.canBeFalse && !left.canBeNull) return left\n  if (right.canBeTrue && !right.canBeFalse && !right.canBeNull) return right\n\n  return {\n    // Either side can be true for the expression to be true\n    canBeTrue: left.canBeTrue || right.canBeTrue,\n    // Both sides must be false for the expression to be false\n    canBeFalse: left.canBeFalse && right.canBeFalse,\n    // if either side can be null, the expression can be null if the other side can't only be true\n    canBeNull: left.canBeNull || right.canBeNull,\n  }\n}\n\nexport function booleanAnd(\n  left: BooleanInterpretation,\n  right: BooleanInterpretation,\n): BooleanInterpretation {\n  // If either side can only be fales, the expression can only be false, so we short-circuit\n  if (left.canBeFalse && !left.canBeTrue && !left.canBeNull) return left\n  if (right.canBeFalse && !right.canBeTrue && !right.canBeNull) return right\n\n  return {\n    // Both sides must be true for the expression to be true\n    canBeTrue: left.canBeTrue && right.canBeTrue,\n    // if either side can be false, the expression can be false\n    canBeFalse: left.canBeFalse || right.canBeFalse,\n    // if either side can be null, the expression can be null\n    canBeNull: left.canBeNull || right.canBeNull,\n  }\n}\n\nexport function booleanInterpretationToTypeNode(bool: BooleanInterpretation): TypeNode {\n  if (bool.canBeTrue) {\n    if (bool.canBeFalse) {\n      if (bool.canBeNull) {\n        return nullUnion({type: 'boolean'})\n      }\n      return {type: 'boolean'}\n    }\n    if (bool.canBeNull) {\n      return nullUnion({type: 'boolean', value: true})\n    }\n    return {type: 'boolean', value: true}\n  }\n\n  if (bool.canBeFalse) {\n    if (bool.canBeNull) {\n      return nullUnion({type: 'boolean', value: false})\n    }\n    return {type: 'boolean', value: false}\n  }\n  return {type: 'null'}\n}\n","/* eslint-disable max-statements */\nimport type {FuncCallNode} from '../nodeTypes'\nimport {optimizeUnions} from './optimizations'\nimport type {Scope} from './scope'\nimport {walk} from './typeEvaluate'\nimport {createGeoJson, mapNode, nullUnion} from './typeHelpers'\nimport type {NullTypeNode, TypeNode} from './types'\n\nfunction unionWithoutNull(unionTypeNode: TypeNode): TypeNode {\n  if (unionTypeNode.type === 'union') {\n    return {\n      type: 'union',\n      of: unionTypeNode.of.filter((type) => type.type !== 'null'),\n    }\n  }\n  return unionTypeNode\n}\n\n// eslint-disable-next-line complexity\nexport function handleFuncCallNode(node: FuncCallNode, scope: Scope): TypeNode {\n  switch (`${node.namespace}.${node.name}`) {\n    case 'array.compact': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'unknown'}})\n        }\n        if (arg.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        const of = mapNode(arg.of, scope, (of) => of)\n        return {\n          type: 'array',\n          of: unionWithoutNull(of),\n        }\n      })\n    }\n\n    case 'array.join': {\n      const arrayArg = walk({node: node.args[0], scope})\n      const sepArg = walk({node: node.args[1], scope})\n\n      return mapNode(arrayArg, scope, (arrayArg) =>\n        mapNode(sepArg, scope, (sepArg) => {\n          if (arrayArg.type === 'unknown' || sepArg.type === 'unknown') {\n            return nullUnion({type: 'string'})\n          }\n          if (arrayArg.type !== 'array' || sepArg.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return mapNode(arrayArg.of, scope, (of) => {\n            if (of.type === 'unknown') {\n              return nullUnion({type: 'string'})\n            }\n            // we can only join strings, numbers, and booleans\n            if (of.type !== 'string' && of.type !== 'number' && of.type !== 'boolean') {\n              return {type: 'null'}\n            }\n\n            return {type: 'string'}\n          })\n        }),\n      )\n    }\n\n    case 'array.unique': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'array', of: {type: 'unknown'}})\n        }\n        if (arg.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        return arg\n      })\n    }\n\n    case 'array.intersects': {\n      const arg1 = walk({node: node.args[0], scope})\n      const arg2 = walk({node: node.args[1], scope})\n\n      return mapNode(arg1, scope, (arg1) =>\n        mapNode(arg2, scope, (arg2) => {\n          if (arg1.type !== 'array') {\n            return {type: 'null'}\n          }\n\n          if (arg2.type !== 'array') {\n            return {type: 'null'}\n          }\n\n          return {type: 'boolean'}\n        }),\n      )\n    }\n\n    case 'global.lower': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type !== 'string') {\n          return {type: 'null'}\n        }\n        if (arg.value !== undefined) {\n          return {\n            type: 'string',\n            value: arg.value.toLowerCase(),\n          }\n        }\n        return {type: 'string'}\n      })\n    }\n    case 'global.upper': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n        if (arg.type !== 'string') {\n          return {type: 'null'}\n        }\n        if (arg.value !== undefined) {\n          return {\n            type: 'string',\n            value: arg.value.toUpperCase(),\n          }\n        }\n        return {type: 'string'}\n      })\n    }\n    case 'dateTime.now': {\n      return {type: 'string'}\n    }\n    case 'global.now': {\n      return {type: 'string'}\n    }\n    case 'global.defined': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (node) => {\n        if (node.type === 'unknown') {\n          return {type: 'boolean'}\n        }\n\n        return {type: 'boolean', value: node.type !== 'null'}\n      })\n    }\n    case 'global.path': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'string') {\n          return {type: 'string'}\n        }\n\n        return {type: 'null'}\n      })\n    }\n    case 'global.coalesce': {\n      if (node.args.length === 0) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      const typeNodes: TypeNode[] = []\n      let canBeNull = true\n      for (const arg of node.args) {\n        const argNode = optimizeUnions(walk({node: arg, scope}))\n\n        // Check if all types are null\n        const allNull =\n          argNode.type === 'null' ||\n          (argNode.type === 'union' && argNode.of.every((t) => t.type === 'null'))\n\n        // Can the argument be null, if all is null, unknown, or if its a union with at least one null or unknown\n        canBeNull =\n          allNull ||\n          argNode.type === 'unknown' ||\n          (argNode.type === 'union' &&\n            argNode.of.some((t) => t.type === 'null' || t.type === 'unknown'))\n\n        // As long as some type is not null or unknown, we add it to the union, but skip nulls\n        if (!allNull) {\n          typeNodes.push(unionWithoutNull(argNode))\n        }\n\n        // If we have a type that can't be null, we can break.\n        if (!canBeNull) {\n          break\n        }\n      }\n\n      // If the last argument can be null, we add null to the union\n      if (canBeNull) {\n        typeNodes.push({type: 'null'} satisfies NullTypeNode)\n      }\n\n      return {\n        type: 'union',\n        of: typeNodes,\n      }\n    }\n\n    case 'global.count': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'array') {\n          return {type: 'number'}\n        }\n\n        return {type: 'null'} satisfies NullTypeNode\n      })\n    }\n\n    case 'global.dateTime': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (arg.type === 'string') {\n          return nullUnion({type: 'string'}) // we don't know wether the string is a valid date or not, so we return a [null, string]-union\n        }\n\n        return {type: 'null'} satisfies NullTypeNode\n      })\n    }\n\n    case 'global.length': {\n      const arg = walk({node: node.args[0], scope})\n\n      return mapNode(arg, scope, (arg) => {\n        if (arg.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n        if (arg.type === 'array' || arg.type === 'string') {\n          return {type: 'number'}\n        }\n\n        return {type: 'null'}\n      })\n    }\n\n    case 'global.references': {\n      return {type: 'boolean'}\n    }\n\n    case 'global.round': {\n      const numNode = walk({node: node.args[0], scope})\n\n      return mapNode(numNode, scope, (num) => {\n        if (num.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        if (num.type !== 'number') {\n          return {type: 'null'}\n        }\n        if (node.args.length === 2) {\n          const precisionNode = walk({node: node.args[1], scope})\n          return mapNode(precisionNode, scope, (precision) => {\n            if (precision.type === 'unknown') {\n              return nullUnion({type: 'number'})\n            }\n\n            if (precision.type !== 'number') {\n              return {type: 'null'}\n            }\n\n            return {type: 'number'}\n          })\n        }\n\n        return {type: 'number'}\n      })\n    }\n\n    case 'global.string': {\n      const arg = walk({node: node.args[0], scope})\n      return mapNode(arg, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'string'})\n        }\n\n        if (node.type === 'string' || node.type === 'number' || node.type === 'boolean') {\n          if (node.value) {\n            return {\n              type: 'string',\n              value: node.value.toString(),\n            }\n          }\n\n          return {\n            type: 'string',\n          }\n        }\n\n        return {type: 'null'}\n      })\n    }\n\n    case 'math.sum': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers, but we should also ignore nulls\n          if (node.type === 'number' || node.type === 'null') {\n            return {type: 'number'}\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'math.avg': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers\n          if (node.type === 'number') {\n            return {type: 'number'}\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'math.max':\n    case 'math.min': {\n      const values = walk({node: node.args[0], scope})\n      // use mapNode to get concrete resolved value, it will also handle cases where the value is a union\n      return mapNode(values, scope, (node) => {\n        if (node.type === 'unknown') {\n          return nullUnion({type: 'number'})\n        }\n\n        // Aggregate functions can only be applied to arrays\n        if (node.type !== 'array') {\n          return {type: 'null'}\n        }\n\n        // Resolve the concrete type of the array elements\n        return mapNode(node.of, scope, (node) => {\n          if (node.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n\n          // Math functions can only be applied to numbers\n          if (node.type === 'number') {\n            return node\n          }\n          return {type: 'null'}\n        })\n      })\n    }\n\n    case 'pt.text': {\n      if (node.args.length === 0) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      return {\n        type: 'string',\n      }\n    }\n\n    case 'string.startsWith': {\n      const strTypeNode = walk({node: node.args[0], scope})\n      const prefixTypeNode = walk({node: node.args[1], scope})\n      return mapNode(strTypeNode, scope, (strNode) => {\n        return mapNode(prefixTypeNode, scope, (prefixNode) => {\n          if (strNode.type === 'unknown' || prefixNode.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n\n          if (strNode.type !== 'string' || prefixNode.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return {type: 'boolean'}\n        })\n      })\n    }\n    case 'string.split': {\n      const strTypeNode = walk({node: node.args[0], scope})\n      const sepTypeNode = walk({node: node.args[1], scope})\n      return mapNode(strTypeNode, scope, (strNode) => {\n        return mapNode(sepTypeNode, scope, (sepNode) => {\n          if (strNode.type === 'unknown' || sepNode.type === 'unknown') {\n            return nullUnion({type: 'array', of: {type: 'string'}})\n          }\n\n          if (strNode.type !== 'string' || sepNode.type !== 'string') {\n            return {type: 'null'}\n          }\n\n          return {type: 'array', of: {type: 'string'}}\n        })\n      })\n    }\n    case 'geo.latLng': {\n      const latTypeNode = walk({node: node.args[0], scope})\n      const lngTypeNode = walk({node: node.args[1], scope})\n      return mapNode(latTypeNode, scope, (latNode) => {\n        return mapNode(lngTypeNode, scope, (lngNode) => {\n          if (latNode.type == 'unknown' || lngNode.type == 'unknown') {\n            return nullUnion(createGeoJson())\n          }\n          if (latNode.type !== 'number' || lngNode.type !== 'number') {\n            return {type: 'null'}\n          }\n\n          return nullUnion(createGeoJson())\n        })\n      })\n    }\n    case 'geo.contains': {\n      return nullUnion({type: 'boolean'})\n    }\n    case 'geo.intersects': {\n      return nullUnion({type: 'boolean'})\n    }\n    case 'geo.distance': {\n      return nullUnion({type: 'number'})\n    }\n    case 'sanity.versionOf': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return nullUnion({type: 'boolean'})\n        }\n        if (typeNode.type !== 'string') {\n          return {type: 'null'}\n        }\n        return {type: 'boolean'}\n      })\n    }\n    case 'sanity.partOfRelease': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return nullUnion({type: 'boolean'})\n        }\n\n        if (typeNode.type !== 'string') {\n          return {type: 'null'}\n        }\n        return {type: 'boolean'}\n      })\n    }\n    case 'documents.get': {\n      const typeNode = walk({node: node.args[0], scope})\n      return mapNode(typeNode, scope, (typeNode) => {\n        if (typeNode.type === 'unknown') {\n          return typeNode\n        }\n\n        if (typeNode.type !== 'object') {\n          return {type: 'null'}\n        }\n\n        return {type: 'unknown'}\n      })\n    }\n    default: {\n      return {type: 'unknown'}\n    }\n  }\n}\n","import {\n  matchAnalyzePattern,\n  matchText,\n  matchTokenize,\n  type Pattern,\n  type Token,\n} from '../evaluator/matching'\nimport type {ConcreteTypeNode} from './typeHelpers'\n\nexport function match(left: ConcreteTypeNode, right: ConcreteTypeNode): boolean | undefined {\n  let tokens: Token[] = []\n  let patterns: Pattern[] = []\n  if (left.type === 'string') {\n    if (left.value === undefined) {\n      return undefined\n    }\n    tokens = tokens.concat(matchTokenize(left.value))\n  }\n  if (left.type === 'array') {\n    if (left.of.type === 'unknown') {\n      return undefined\n    }\n    if (left.of.type === 'string') {\n      // eslint-disable-next-line max-depth\n      if (left.of.value === undefined) {\n        return undefined\n      }\n\n      tokens = tokens.concat(matchTokenize(left.of.value))\n    }\n    if (left.of.type === 'union') {\n      // eslint-disable-next-line max-depth\n      for (const node of left.of.of) {\n        // eslint-disable-next-line max-depth\n        if (node.type === 'string' && node.value !== undefined) {\n          tokens = tokens.concat(matchTokenize(node.value))\n        }\n      }\n    }\n  }\n\n  if (right.type === 'string') {\n    if (right.value === undefined) {\n      return undefined\n    }\n    patterns = patterns.concat(matchAnalyzePattern(right.value))\n  }\n  if (right.type === 'array') {\n    if (right.of.type === 'unknown') {\n      return undefined\n    }\n    if (right.of.type === 'string') {\n      // eslint-disable-next-line max-depth\n      if (right.of.value === undefined) {\n        return undefined\n      }\n      patterns = patterns.concat(matchAnalyzePattern(right.of.value))\n    }\n    if (right.of.type === 'union') {\n      // eslint-disable-next-line max-depth\n      for (const node of right.of.of) {\n        // eslint-disable-next-line max-depth\n        if (node.type === 'string') {\n          // eslint-disable-next-line max-depth\n          if (node.value === undefined) {\n            return undefined\n          }\n          patterns = patterns.concat(matchAnalyzePattern(node.value))\n        }\n\n        // eslint-disable-next-line max-depth\n        if (node.type !== 'string') {\n          return false\n        }\n      }\n    }\n  }\n  return matchText(tokens, patterns)\n}\n","import debug from 'debug'\n\nimport type {InlineTypeNode, NullTypeNode, Schema, TypeNode, UnionTypeNode} from './types'\n\nconst $trace = debug('typeEvaluator:scope:trace')\n$trace.log = console.log.bind(console) // eslint-disable-line no-console\n\nexport class Context {\n  readonly schema: Schema\n\n  constructor(schema: Schema) {\n    this.schema = schema\n  }\n\n  lookupRef(refTo: string): TypeNode {\n    for (const val of this.schema) {\n      if (val.type === 'document') {\n        if (val.name === refTo) {\n          return {\n            type: 'object',\n            attributes: val.attributes,\n          }\n        }\n      }\n    }\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  lookupTypeDeclaration(alias: InlineTypeNode): TypeNode {\n    for (const val of this.schema) {\n      if (val.type === 'type') {\n        if (val.name === alias.name) {\n          return val.value\n        }\n      }\n    }\n    return {type: 'null'} satisfies NullTypeNode\n  }\n}\n\nexport class Scope {\n  public value: UnionTypeNode\n  public parent: Scope | undefined\n  public context: Context\n  public isHidden: boolean\n\n  constructor(value: TypeNode[], parent?: Scope, context?: Context) {\n    this.value = {type: 'union', of: value} satisfies UnionTypeNode\n    this.parent = parent\n    this.context = context || parent?.context || new Context([])\n    this.isHidden = false\n  }\n\n  createNested(value: TypeNode[]): Scope {\n    if (this.isHidden) {\n      return new Scope(value, this.parent, this.context)\n    }\n    return new Scope(value, this, this.context)\n  }\n\n  createHidden(value: TypeNode[]): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n","import debug from 'debug'\n\nimport type {\n  AccessAttributeNode,\n  AccessElementNode,\n  AndNode,\n  ArrayCoerceNode,\n  ArrayNode,\n  DerefNode,\n  EverythingNode,\n  ExprNode,\n  FilterNode,\n  FlatMapNode,\n  MapNode,\n  NegNode,\n  NotNode,\n  ObjectConditionalSplatNode,\n  ObjectNode,\n  ObjectSplatNode,\n  OpCall,\n  OpCallNode,\n  OrNode,\n  ParentNode,\n  PosNode,\n  ProjectionNode,\n  SelectNode,\n  SliceNode,\n  ValueNode,\n} from '../nodeTypes'\nimport {booleanAnd, booleanInterpretationToTypeNode, booleanOr, booleanValue} from './booleans'\nimport {handleFuncCallNode} from './functions'\nimport {match} from './matching'\nimport {optimizeUnions} from './optimizations'\nimport {Context, Scope} from './scope'\nimport {isFuncCall, mapNode, nullUnion, resolveInline} from './typeHelpers'\nimport type {\n  ArrayTypeNode,\n  BooleanTypeNode,\n  Document,\n  NullTypeNode,\n  NumberTypeNode,\n  ObjectAttribute,\n  ObjectTypeNode,\n  PrimitiveTypeNode,\n  Schema,\n  StringTypeNode,\n  TypeNode,\n  UnionTypeNode,\n  UnknownTypeNode,\n} from './types'\n\nconst $trace = debug('typeEvaluator:evaluate:trace')\n$trace.log = console.log.bind(console) // eslint-disable-line no-console\n// log to stdout\nconst $debug = debug('typeEvaluator:evaluate:debug')\n// log to stdout\n$debug.log = console.log.bind(console) // eslint-disable-line no-console\nconst $warn = debug('typeEvaluator:evaluate:warn')\n\n/**\n * Evaluates the type of a query and schema.\n *\n * @param ast - The query ast to evaluate.\n * @param schema - The schemas to use for type evaluation.\n * @returns The type of the query.\n * @beta\n */\nexport function typeEvaluate(ast: ExprNode, schema: Schema): TypeNode {\n  $debug('evaluateQueryType.ast %O', ast)\n  $debug('evaluateQueryType.schema %O', schema)\n  const parsed = walk({\n    node: ast,\n    scope: new Scope([], undefined, new Context(schema)),\n  })\n\n  $trace('evaluateQueryType.parsed %O', parsed)\n  const optimized = optimizeUnions(parsed)\n  $debug('evaluateQueryType.optimized %O', optimized)\n\n  return optimized\n}\n\nfunction mapDeref(node: TypeNode, scope: Scope): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'array') {\n      return {\n        type: 'array',\n        of: mapDeref(base.of, scope),\n      }\n    }\n\n    if (base.type === 'object') {\n      if (base.dereferencesTo !== undefined) {\n        return scope.context.lookupRef(base.dereferencesTo)\n      }\n\n      if (base.rest !== undefined) {\n        return mapDeref(resolveInline(base.rest, scope), scope)\n      }\n    }\n\n    return {type: 'null'}\n  })\n}\n\nfunction handleDerefNode(node: DerefNode, scope: Scope): TypeNode {\n  $trace('deref.node %O', node)\n  const derefedNode = mapDeref(walk({node: node.base, scope}), scope)\n  $trace('deref.derefedNode %O', derefedNode)\n\n  return derefedNode\n}\n\nfunction handleObjectSplatNode(\n  attr: ObjectSplatNode | ObjectConditionalSplatNode,\n  scope: Scope,\n): TypeNode {\n  const value = walk({node: attr.value, scope})\n  $trace('object.splat.value %O', value)\n  return mapNode(value, scope, (node) => {\n    // splatting over unknown is unknown, we can't know what the attributes are\n    if (node.type === 'unknown') {\n      return {type: 'unknown'}\n    }\n    // splatting over a non-object is a no-op\n    if (node.type !== 'object') {\n      return {type: 'object', attributes: {}}\n    }\n\n    const attributes: Record<string, ObjectAttribute> = {}\n    for (const name in node.attributes) {\n      if (!node.attributes.hasOwnProperty(name)) {\n        continue\n      }\n      attributes[name] = node.attributes[name]\n    }\n\n    if (node.rest !== undefined) {\n      // Rest is either an object, inline, or unknown - we need to resolve it if it's an inline\n      const resolvedRest = resolveInline(node.rest, scope)\n\n      // if the rest is unknown the entire object is unknown\n      if (resolvedRest.type === 'unknown') {\n        return {type: 'unknown'}\n      }\n      if (resolvedRest.type !== 'object') {\n        return {type: 'null'}\n      }\n      for (const name in resolvedRest.attributes) {\n        // eslint-disable-next-line\n        if (!resolvedRest.attributes.hasOwnProperty(name)) {\n          continue\n        }\n        attributes[name] = resolvedRest.attributes[name]\n      }\n    }\n    return {type: 'object', attributes}\n  })\n}\n\n// eslint-disable-next-line max-statements, complexity\nfunction handleObjectNode(node: ObjectNode, scope: Scope): TypeNode {\n  $trace('object.node %O', node)\n\n  if (node.attributes.length === 0) {\n    return {\n      type: 'object',\n      attributes: {},\n    } satisfies ObjectTypeNode\n  }\n\n  // let attributes we a entry of [name, value] or null. We need to keep track of nulls to handle conditional splats\n  // since we care about the order of the attributes. Later attribute keys will overwrite earlier ones.\n  const objectAttributes: [number, string, ObjectAttribute][] = []\n\n  const splatVariants: [number, ObjectTypeNode | UnionTypeNode<ObjectTypeNode>][] = []\n\n  // We keep track of conditional splats separately, since we need to merge them into an object or an union of objects at the end.\n  // keep track of the index of the conditional splat to be able to merge the attributes correctly.\n  const conditionalVariants: [number, UnionTypeNode<ObjectTypeNode>][] = []\n\n  for (const [idx, attr] of node.attributes.entries()) {\n    if (attr.type === 'ObjectAttributeValue') {\n      const attributeNode = walk({node: attr.value, scope})\n      objectAttributes.push([\n        idx,\n        attr.name,\n        {\n          type: 'objectAttribute',\n          value: attributeNode,\n        },\n      ])\n      continue\n    }\n\n    if (attr.type === 'ObjectSplat') {\n      const attributeNode = handleObjectSplatNode(attr, scope)\n      $trace('object.splat.result %O', attributeNode)\n      switch (attributeNode.type) {\n        case 'object': {\n          splatVariants.push([idx, attributeNode])\n          continue\n        }\n        case 'union': {\n          for (const node of attributeNode.of) {\n            // if one of the nodes is unknown we mark the entire object as unknown as we can't infer the type of the object\n            // eslint-disable-next-line max-depth\n            if (node.type === 'unknown') {\n              return node\n            }\n          }\n          splatVariants.push([idx, attributeNode as UnionTypeNode<ObjectTypeNode>])\n          continue\n        }\n        default: {\n          return {type: 'unknown'}\n        }\n      }\n    }\n\n    if (attr.type === 'ObjectConditionalSplat') {\n      const condition = booleanValue(walk({node: attr.condition, scope}), scope)\n      $trace('object.conditional.splat.condition %O', condition)\n      // condition is never met, skip this attribute\n      if (condition.canBeTrue === false) {\n        continue\n      }\n\n      const attributeNode = handleObjectSplatNode(attr, scope)\n      $trace('object.conditional.splat.result %O', attributeNode)\n      // condition is always met, we can treat this as a normal splat\n      if (condition.canBeFalse === false && condition.canBeNull === false) {\n        switch (attributeNode.type) {\n          case 'object': {\n            splatVariants.push([idx, attributeNode])\n            continue\n          }\n          case 'union': {\n            // eslint-disable-next-line max-depth\n            for (const node of attributeNode.of) {\n              // eslint-disable-next-line max-depth\n              if (node.type !== 'object') {\n                return {type: 'unknown'}\n              }\n            }\n            splatVariants.push([idx, attributeNode as UnionTypeNode<ObjectTypeNode>])\n            continue\n          }\n          default: {\n            return {type: 'unknown'}\n          }\n        }\n      }\n\n      const variant = mapNode(attributeNode, scope, (attributeNode) => {\n        $trace('object.conditional.splat.result.concrete %O', attributeNode)\n        if (attributeNode.type !== 'object') {\n          return {type: 'unknown'}\n        }\n\n        return {\n          type: 'object',\n          attributes: attributeNode.attributes,\n        } satisfies ObjectTypeNode\n      })\n\n      if (variant.type === 'union') {\n        for (const node of variant.of) {\n          // We can only splat objects, so we bail out if we encounter a non-object node.\n          // eslint-disable-next-line max-depth\n          if (node.type !== 'object') {\n            return {type: 'unknown'}\n          }\n        }\n        variant.of.push({type: 'object', attributes: {}} as ObjectTypeNode) // add an empty object to the union, since it's conditional\n        conditionalVariants.push([idx, variant as UnionTypeNode<ObjectTypeNode>])\n        continue\n      }\n      // If the variant is not an object or a union of objects, we bail out early.\n      if (variant.type !== 'object') {\n        return {type: 'unknown'}\n      }\n\n      conditionalVariants.push([\n        idx,\n        {\n          type: 'union',\n          of: [{type: 'object', attributes: {}}, variant],\n        },\n      ])\n      continue\n    }\n\n    // @ts-expect-error - we should have handled all cases of ObjectAttributeNode\n    throw new Error(`Unknown object attribute type: ${attr.type}`)\n  }\n\n  const guaranteedAttributes: [number, string, ObjectAttribute<TypeNode>][] = []\n  guaranteedAttributes.push(...objectAttributes)\n\n  for (const [idx, splatNode] of splatVariants) {\n    if (splatNode.type === 'object') {\n      for (const name in splatNode.attributes) {\n        if (!splatNode.attributes.hasOwnProperty(name)) {\n          continue\n        }\n        const attribute = splatNode.attributes[name]\n        guaranteedAttributes.push([idx, name, attribute])\n      }\n      continue\n    }\n\n    // it's a union of objects, so we keep this as a conditional variant\n    conditionalVariants.push([idx, splatNode])\n  }\n\n  // make sure they are sorted from lowest index to highest, this ensures that\n  // attributes with a higher index overwrite attributes with a lower index.\n  guaranteedAttributes.sort(([a], [b]) => a - b)\n\n  // If we have no conditional variants, we can just return the object with the guaranteed attributes.\n  if (conditionalVariants.length === 0) {\n    return {\n      type: 'object',\n      attributes: Object.fromEntries(\n        guaranteedAttributes.map(([, name, attribute]) => [name, attribute]),\n      ),\n    } satisfies ObjectTypeNode\n  }\n\n  // matrix should be a result of if given we have variants [a,b,c] this would lead to a union of [a, a|b, a|c, a|b|c, b|c, c, {EMPTY}]\n  // if it's given we have variants A + [a|b|c] this would lead to a union of [Aa, Aa|Ab, Aa|Ac, Aa|Ab|Ac, Ab|Ac, Ac, A]\n  const matrix: (ObjectTypeNode | UnionTypeNode<ObjectTypeNode>)[] = []\n\n  for (const [unionIdx, union] of conditionalVariants) {\n    const unionGuaranteedBefore: [number, string, ObjectAttribute][] = []\n    const unionGuaranteedAfter: [number, string, ObjectAttribute][] = []\n\n    // Collect all guaranteed attributes before and after the conditional variant.\n    for (const [guaranteedIndex, name, attribute] of guaranteedAttributes) {\n      if (guaranteedIndex < unionIdx) {\n        unionGuaranteedBefore.push([guaranteedIndex, name, attribute])\n      }\n      if (guaranteedIndex > unionIdx) {\n        unionGuaranteedAfter.push([guaranteedIndex, name, attribute])\n      }\n    }\n\n    // build a map of variants from other conditions.\n    const allVariantsAttributes: [number, Record<string, ObjectAttribute>[]][] = []\n    for (const [conditionalVariantIdx, otherUnion] of conditionalVariants) {\n      // We need to build a matrix of all possible combinations of the attributes of the other variants.\n      // start with an empty object, since it's condtional.\n      const variantAttributes: Record<string, ObjectAttribute>[] = []\n      for (const node of otherUnion.of) {\n        variantAttributes.push(node.attributes)\n      }\n      allVariantsAttributes.push([conditionalVariantIdx, variantAttributes])\n    }\n\n    /* eslint-disable max-depth */\n    for (const node of union.of) {\n      matrix.push({\n        type: 'object',\n        attributes: {\n          ...Object.fromEntries(\n            unionGuaranteedBefore.map(([, name, attribute]) => [name, attribute]),\n          ),\n          ...node.attributes,\n          ...Object.fromEntries(\n            unionGuaranteedAfter.map(([, name, attribute]) => [name, attribute]),\n          ),\n        },\n      } satisfies ObjectTypeNode)\n\n      for (const [outerIdx, outerAttributes] of allVariantsAttributes) {\n        for (const outer of outerAttributes) {\n          for (const [innerIdx, innerAttributes] of allVariantsAttributes) {\n            if (outerIdx === innerIdx) {\n              continue\n            }\n\n            for (const inner of innerAttributes) {\n              const _before = [...unionGuaranteedBefore]\n              const _after = [...unionGuaranteedAfter]\n\n              for (const name in outer) {\n                if (!outer.hasOwnProperty(name)) {\n                  continue\n                }\n\n                if (outerIdx === unionIdx) {\n                  continue\n                }\n\n                if (outerIdx < unionIdx) {\n                  _before.push([outerIdx, name, outer[name]])\n                }\n\n                if (outerIdx > unionIdx) {\n                  _after.push([outerIdx, name, outer[name]])\n                }\n              }\n\n              for (const name in inner) {\n                if (!inner.hasOwnProperty(name)) {\n                  continue\n                }\n                if (outerIdx === unionIdx) {\n                  continue\n                }\n\n                if (innerIdx < unionIdx) {\n                  _before.push([innerIdx, name, inner[name]])\n                }\n\n                if (innerIdx > unionIdx) {\n                  _after.push([innerIdx, name, inner[name]])\n                }\n              }\n              _before.sort(([a], [b]) => a - b)\n              _after.sort(([a], [b]) => a - b)\n\n              const before: Record<string, ObjectAttribute> = Object.fromEntries(\n                _before.map(([, name, attribute]) => [name, attribute]),\n              )\n\n              const after: Record<string, ObjectAttribute> = Object.fromEntries(\n                _after.map(([, name, attribute]) => [name, attribute]),\n              )\n\n              matrix.push({\n                type: 'object',\n                attributes: {\n                  ...before,\n                  ...node.attributes,\n                  ...after,\n                },\n              })\n            }\n          }\n        }\n      }\n    }\n    /* eslint-disable max-depth */\n  }\n\n  return optimizeUnions({\n    type: 'union',\n    of: matrix,\n  })\n}\n\n// eslint-disable-next-line max-statements\nfunction handleOpCallNode(node: OpCallNode, scope: Scope): TypeNode {\n  $trace('opcall.node %O', node)\n  const lhs = walk({node: node.left, scope})\n  const rhs = walk({node: node.right, scope})\n  return mapNode(lhs, scope, (left) =>\n    // eslint-disable-next-line complexity, max-statements\n    mapNode(rhs, scope, (right) => {\n      $trace('opcall.node.concrete \"%s\" %O', node.op, {left, right})\n\n      switch (node.op) {\n        case '==': {\n          // == always returns a boolean, no matter the compared types.\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return {type: 'boolean'}\n          }\n          if (left.type !== right.type) {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          if (left.type === 'null') {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          return {\n            type: 'boolean',\n            value: evaluateComparison(node.op, left, right),\n          } satisfies BooleanTypeNode\n        }\n        case '!=': {\n          // != always returns a boolean, no matter the compared types.\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return {type: 'boolean'}\n          }\n          if (left.type !== right.type) {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n          if (left.type === 'null') {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {\n              type: 'boolean',\n              value: true,\n            } satisfies BooleanTypeNode\n          }\n\n          let value = evaluateComparison('==', left, right)\n          if (value !== undefined) value = !value\n          return {\n            type: 'boolean',\n            value,\n          } satisfies BooleanTypeNode\n        }\n        case '>':\n        case '>=':\n        case '<':\n        case '<=': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n          if (left.type !== right.type) {\n            return {type: 'null'} satisfies NullTypeNode\n          }\n          if (!isPrimitiveTypeNode(left) || !isPrimitiveTypeNode(right)) {\n            return {type: 'null'} satisfies NullTypeNode\n          }\n          return {\n            type: 'boolean',\n            value: evaluateComparison(node.op, left, right),\n          } satisfies BooleanTypeNode\n        }\n        case 'in': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'boolean'})\n          }\n          if (right.type !== 'array') {\n            // Special case for global::path, since it can be used with in operator, but the type returned otherwise is a string\n            if (isFuncCall(node.right, 'global::path')) {\n              return {type: 'boolean'}\n            }\n            return {type: 'null'}\n          }\n          if (!isPrimitiveTypeNode(left) && left.type !== 'null') {\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          }\n          return mapNode(right.of, scope, (arrayTypeNode) => {\n            if (arrayTypeNode.type === 'unknown') {\n              return nullUnion({type: 'boolean'})\n            }\n\n            if (left.type === 'null') {\n              return {\n                type: 'boolean',\n                value: arrayTypeNode.type === 'null',\n              } satisfies BooleanTypeNode\n            }\n\n            if (left.value === undefined) {\n              return {\n                type: 'boolean',\n              } satisfies BooleanTypeNode\n            }\n            if (isPrimitiveTypeNode(arrayTypeNode)) {\n              if (arrayTypeNode.value === undefined) {\n                return {\n                  type: 'boolean',\n                } satisfies BooleanTypeNode\n              }\n\n              return {\n                type: 'boolean',\n                value: left.value === arrayTypeNode.value,\n              } satisfies BooleanTypeNode\n            }\n\n            return {\n              type: 'boolean',\n              value: false,\n            } satisfies BooleanTypeNode\n          })\n        }\n        case 'match': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            // match always returns a boolean, no matter the compared types.\n            return {type: 'boolean'}\n          }\n          return {\n            type: 'boolean',\n            value: match(left, right),\n          } satisfies BooleanTypeNode\n        }\n        case '+': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            // + is ambiguous without the concrete types of the operands, so we return unknown and leave the excersise to the caller\n            return {type: 'unknown'}\n          }\n          if (left.type === 'string' && right.type === 'string') {\n            return {\n              type: 'string',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value + right.value\n                  : undefined,\n            }\n          }\n\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value + right.value\n                  : undefined,\n            }\n          }\n          if (left.type === 'array' && right.type === 'array') {\n            return {\n              type: 'array',\n              of: {\n                type: 'union',\n                of: [left.of, right.of],\n              },\n            } satisfies ArrayTypeNode\n          }\n          if (left.type === 'object' && right.type === 'object') {\n            return {\n              type: 'object',\n              attributes: {...left.attributes, ...right.attributes},\n            } satisfies ObjectTypeNode\n          }\n          return {type: 'null'}\n        }\n        case '-': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value - right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '*': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value * right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '/': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value / right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '**': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value ** right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        case '%': {\n          if (left.type === 'unknown' || right.type === 'unknown') {\n            return nullUnion({type: 'number'})\n          }\n          if (left.type === 'number' && right.type === 'number') {\n            return {\n              type: 'number',\n              value:\n                left.value !== undefined && right.value !== undefined\n                  ? left.value % right.value\n                  : undefined,\n            }\n          }\n          return {type: 'null'}\n        }\n        default: {\n          // TS only: make sure we handle all cases\n          node.op satisfies never\n\n          return {\n            type: 'unknown',\n          } satisfies UnknownTypeNode\n        }\n      }\n    }),\n  )\n}\n\nfunction handleSelectNode(node: SelectNode, scope: Scope): TypeNode {\n  const values: TypeNode[] = []\n  let guaranteed = false\n  for (const alternative of node.alternatives) {\n    const conditionValue = walk({node: alternative.condition, scope})\n    const conditionScope = resolveFilter(alternative.condition, scope)\n    if (conditionScope.type === 'union' && conditionScope.of.length > 0) {\n      values.push(walk({node: alternative.value, scope: scope.createHidden(conditionScope.of)}))\n    }\n    if (conditionValue.type === 'boolean' && conditionValue.value === true) {\n      guaranteed = true\n    }\n  }\n  if (node.fallback && !guaranteed) {\n    values.push(walk({node: node.fallback, scope}))\n  }\n  if (values.length === 0) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  return {\n    type: 'union',\n    of: values,\n  } satisfies UnionTypeNode\n}\n\nfunction handleArrayCoerceNode(node: ArrayCoerceNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('arrayCoerce.base %O', base)\n  return mapArray(base, scope, (base) => base)\n}\nfunction handleFlatMap(node: FlatMapNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapArray(base, scope, (base) => {\n    const inner = walk({node: node.expr, scope: scope.createHidden([base.of])})\n\n    return mapNode(\n      inner,\n      scope,\n      (inner) => {\n        if (inner.type === 'array') {\n          return inner\n        }\n\n        return {type: 'array', of: inner}\n      },\n      (nodes) => {\n        const inner: TypeNode[] = []\n        for (const node of nodes) {\n          // Bail out early if we've detected an unknown.\n          if (node.type === 'unknown') return {type: 'array', of: node}\n          // The mapper above ensures that all types returned are arrays.\n          if (node.type !== 'array') throw new Error(`Unexpected type: ${node.type}`)\n          inner.push(node.of)\n        }\n        return {\n          type: 'array',\n          of: optimizeUnions({type: 'union', of: inner}),\n        }\n      },\n    )\n  })\n}\nfunction handleMap(node: MapNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('map.base %O', base)\n\n  return mapArray(base, scope, (base) => {\n    return {\n      type: 'array',\n      of: walk({node: node.expr, scope: scope.createHidden([base.of])}),\n    }\n  })\n}\n\nfunction handleProjectionNode(node: ProjectionNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('projection.base %O', base)\n\n  return mapObject(base, scope, (base) =>\n    walk({node: node.expr, scope: scope.createNested([base])}),\n  )\n}\n\nfunction createFilterScope(base: TypeNode, scope: Scope): Scope {\n  if (base.type === 'array') {\n    if (base.of.type === 'union') {\n      return scope.createNested(base.of.of)\n    }\n    return scope.createNested([base.of])\n  }\n\n  return scope.createNested([base])\n}\nfunction handleFilterNode(node: FilterNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('filter.base %O', base)\n\n  return mapNode(base, scope, (base) => {\n    $trace('filter.resolving %O', base)\n    if (base.type === 'null') {\n      return base\n    }\n\n    const resolved = resolveFilter(node.expr, createFilterScope(base, scope))\n    $trace('filter.resolved %O', resolved)\n\n    return {\n      type: 'array',\n      of: resolved,\n    }\n  })\n}\n\nexport function handleAccessAttributeNode(node: AccessAttributeNode, scope: Scope): TypeNode {\n  let attributeBase: TypeNode = scope.value\n  if (node.base) {\n    attributeBase = walk({node: node.base, scope})\n  }\n\n  $trace('accessAttribute.base %s %O', node.name, attributeBase)\n  return handleAccessAttributeBase(attributeBase, node.name, scope)\n}\n\nfunction handleAccessAttributeBase(base: TypeNode, name: string, scope: Scope): TypeNode {\n  return mapObject(base, scope, (base) => {\n    $trace(`Looking for attribute \"%s\" in object %O`, name, base)\n\n    const attribute = base.attributes[name]\n    if (attribute !== undefined) {\n      $debug(`accessAttribute.attribute found ${name} %O`, attribute)\n      if (attribute.optional) {\n        return nullUnion(attribute.value)\n      }\n\n      return attribute.value\n    }\n\n    if (base.rest) {\n      return handleAccessAttributeBase(base.rest, name, scope)\n    }\n    $warn(`attribute \"${name}\" not found in object`)\n    return {type: 'null'}\n  })\n}\n\nfunction handleAccessElementNode(node: AccessElementNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  $trace('accessElement.base %O', base)\n  return mapArray(base, scope, (base) => nullUnion(base.of))\n}\n\nfunction handleArrayNode(node: ArrayNode, scope: Scope): TypeNode {\n  const of: TypeNode[] = []\n  for (const el of node.elements) {\n    const node = walk({node: el.value, scope})\n    if (node !== null) {\n      of.push(node)\n    }\n  }\n  return {\n    type: 'array',\n    of: {\n      type: 'union',\n      of,\n    } satisfies UnionTypeNode,\n  } satisfies ArrayTypeNode\n}\n\nfunction handleValueNode(node: ValueNode, scope: Scope): TypeNode {\n  if (node.value === null) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n  switch (typeof node.value) {\n    case 'string':\n      return {\n        type: 'string',\n        value: node.value,\n      } satisfies StringTypeNode\n    case 'number':\n      return {\n        type: 'number',\n        value: node.value,\n      } satisfies NumberTypeNode\n    case 'boolean':\n      return {\n        type: 'boolean',\n        value: node.value,\n      } satisfies BooleanTypeNode\n    case 'object':\n      if (node.value === null) {\n        return {type: 'null'} satisfies NullTypeNode\n      }\n      if (Array.isArray(node.value)) {\n        return {\n          type: 'array',\n          of: {\n            type: 'union',\n            of: node.value.map((value) => walk({node: {type: 'Value', value}, scope})),\n          },\n        } satisfies ArrayTypeNode\n      }\n      return {\n        type: 'object',\n        attributes: Object.fromEntries(\n          Object.entries(node.value).map(([key, value]) => [\n            key,\n            {\n              type: 'objectAttribute',\n              value: walk({node: {type: 'Value', value}, scope}),\n            },\n          ]),\n        ),\n      } satisfies ObjectTypeNode\n    default:\n      return {type: 'unknown'} satisfies UnknownTypeNode\n  }\n}\n\nfunction handleSlice(node: SliceNode, scope: Scope): TypeNode {\n  $trace('slice.node %O', node)\n  const base = walk({node: node.base, scope})\n  return mapArray(base, scope, (base) => base)\n}\n\nfunction handleParentNode({n}: ParentNode, scope: Scope): TypeNode {\n  $trace('handle.parent.currentScope %d %O', n, scope)\n\n  let current: Scope | undefined = scope\n  for (let i = 0; i < n; i++) {\n    // make sure we are not in a hidden scope\n    while (current?.isHidden) {\n      current = current.parent\n    }\n    current = current?.parent\n  }\n  $trace('handle.parent.newScope %d %O', n, current)\n\n  if (!current) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  if (current.value.of.length === 0) {\n    return {type: 'null'} satisfies NullTypeNode\n  }\n\n  return current.value\n}\n\nfunction handleNotNode(node: NotNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'boolean'})\n    }\n\n    if (base.type === 'boolean') {\n      if (base.value !== undefined) {\n        return {type: 'boolean', value: base.value === false}\n      }\n      return {type: 'boolean'}\n    }\n\n    return {type: 'null'}\n  })\n}\n\nfunction handleNegNode(node: NegNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'number'})\n    }\n\n    if (base.type !== 'number') {\n      return {type: 'null'}\n    }\n    if (base.value !== undefined) {\n      return {type: 'number', value: -base.value}\n    }\n    return base\n  })\n}\nfunction handlePosNode(node: PosNode, scope: Scope): TypeNode {\n  const base = walk({node: node.base, scope})\n  return mapNode(base, scope, (base) => {\n    if (base.type === 'unknown') {\n      return nullUnion({type: 'number'})\n    }\n    if (base.type !== 'number') {\n      return {type: 'null'}\n    }\n    return base\n  })\n}\n\nfunction handleEverythingNode(_: EverythingNode, scope: Scope): TypeNode {\n  return {\n    type: 'array',\n    of: {\n      type: 'union',\n      of: scope.context.schema\n        .filter((obj): obj is Document => obj.type === 'document')\n        .map((doc) => ({\n          type: 'object',\n          attributes: doc.attributes,\n        })),\n    },\n  } satisfies ArrayTypeNode<UnionTypeNode<ObjectTypeNode>>\n}\n\nfunction handleAndNode(node: AndNode, scope: Scope): TypeNode {\n  const left = walk({node: node.left, scope})\n  const right = walk({node: node.right, scope})\n  return mapNode(left, scope, (lhs) =>\n    mapNode(right, scope, (rhs) => {\n      const value = booleanAnd(booleanValue(lhs, scope), booleanValue(rhs, scope))\n\n      return booleanInterpretationToTypeNode(value)\n    }),\n  )\n}\n\nfunction handleOrNode(node: OrNode, scope: Scope): TypeNode {\n  const left = walk({node: node.left, scope})\n  const right = walk({node: node.right, scope})\n  return mapNode(left, scope, (lhs) =>\n    mapNode(right, scope, (rhs) => {\n      const value = booleanOr(booleanValue(lhs, scope), booleanValue(rhs, scope))\n\n      return booleanInterpretationToTypeNode(value)\n    }),\n  )\n}\n\nconst OVERRIDE_TYPE_SYMBOL = Symbol('groq-js.type')\n\n/**\n * `overrideTypeForNode` overrides the inferred type for a specific node: The\n * type evaluator will ignore its built-in logic and instead _always_ return\n * this type. This is intended to be used for testing.\n * @internal - This is only exported for testing purposes.\n */\nexport function overrideTypeForNode(node: ExprNode, type: TypeNode): void {\n  ;(node as any)[OVERRIDE_TYPE_SYMBOL] = type\n}\n\n/**\n * Walks through the AST and evaluates the type of each node.\n *\n * @param node - The AST node to evaluate.\n * @param scope - The current scope.\n * @returns The evaluated type of the node.\n * @internal\n */\n// eslint-disable-next-line complexity\nexport function walk({node, scope}: {node: ExprNode; scope: Scope}): TypeNode {\n  if (OVERRIDE_TYPE_SYMBOL in node) {\n    return node[OVERRIDE_TYPE_SYMBOL] as TypeNode\n  }\n\n  switch (node.type) {\n    // Filtering, traversal & projections\n    case 'Map': {\n      return handleMap(node, scope)\n    }\n    case 'Projection': {\n      return handleProjectionNode(node, scope)\n    }\n    case 'Filter': {\n      return handleFilterNode(node, scope)\n    }\n    case 'AccessAttribute': {\n      return optimizeUnions(handleAccessAttributeNode(node, scope))\n    }\n    case 'AccessElement': {\n      return handleAccessElementNode(node, scope)\n    }\n    case 'ArrayCoerce': {\n      return handleArrayCoerceNode(node, scope)\n    }\n    case 'FlatMap': {\n      return handleFlatMap(node, scope)\n    }\n\n    // Operations\n    case 'OpCall': {\n      return handleOpCallNode(node, scope)\n    }\n\n    case 'And': {\n      return handleAndNode(node, scope)\n    }\n\n    case 'Or': {\n      return handleOrNode(node, scope)\n    }\n\n    case 'Select': {\n      return handleSelectNode(node, scope)\n    }\n    case 'PipeFuncCall': {\n      return walk({node: node.base, scope})\n    }\n\n    // Values\n    case 'Deref': {\n      return handleDerefNode(node, scope)\n    }\n    case 'Object': {\n      return handleObjectNode(node, scope)\n    }\n    case 'Value': {\n      return handleValueNode(node, scope)\n    }\n    case 'Array': {\n      return handleArrayNode(node, scope)\n    }\n\n    // Special cases\n    case 'Everything': {\n      return handleEverythingNode(node, scope)\n    }\n\n    case 'This': {\n      $trace('this %O', scope.value)\n      return scope.value\n    }\n\n    case 'Parent': {\n      return handleParentNode(node, scope)\n    }\n    case 'FuncCall': {\n      return handleFuncCallNode(node, scope)\n    }\n    case 'Group': {\n      return walk({node: node.base, scope})\n    }\n    case 'Not': {\n      return handleNotNode(node, scope)\n    }\n    case 'Parameter': {\n      return {\n        type: 'unknown',\n      }\n    }\n\n    case 'Slice': {\n      return handleSlice(node, scope)\n    }\n    case 'Neg': {\n      return handleNegNode(node, scope)\n    }\n    case 'Pos': {\n      return handlePosNode(node, scope)\n    }\n    // everything else\n    case 'Asc':\n    case 'Desc':\n    case 'Context':\n    case 'Tuple':\n    case 'SelectorFuncCall':\n    case 'SelectorNested':\n    case 'InRange': {\n      return {type: 'unknown'}\n    }\n\n    default: {\n      // @ts-expect-error - we should have handled all cases\n      throw new Error(`unknown node type ${node.type}`)\n    }\n  }\n}\n\nfunction isPrimitiveTypeNode(node: TypeNode): node is PrimitiveTypeNode {\n  return node.type === 'string' || node.type === 'number' || node.type === 'boolean'\n}\n\nfunction evaluateComparison(\n  opcall: OpCall,\n  left: PrimitiveTypeNode,\n  right: PrimitiveTypeNode,\n): boolean | undefined {\n  if (left.value === undefined || right.value === undefined) {\n    return undefined\n  }\n  switch (opcall) {\n    case '==': {\n      return left.value === right.value\n    }\n    case '<': {\n      return left.value < right.value\n    }\n    case '<=': {\n      return left.value <= right.value\n    }\n    case '>': {\n      return left.value > right.value\n    }\n    case '>=': {\n      return left.value >= right.value\n    }\n    default: {\n      throw new Error(`unknown comparison operator ${opcall}`)\n    }\n  }\n}\n\n// eslint-disable-next-line complexity, max-statements\nfunction resolveFilter(expr: ExprNode, scope: Scope): UnionTypeNode {\n  $trace('resolveFilter.expr %O', expr)\n  const filtered = scope.value.of.filter((node) => {\n    // create a new scope with the current scopes parent as the parent. It's only a temporary scope since we only want to resolve the condition\n    // and check if the result can be true.\n    const subScope = scope.createHidden([node])\n    const cond = walk({node: expr, scope: subScope})\n    return booleanValue(cond, subScope).canBeTrue\n  })\n  $trace(\n    `resolveFilter ${expr.type === 'OpCall' ? `${expr.type}/${expr.op}` : expr.type} %O`,\n    filtered,\n  )\n  return {type: 'union', of: filtered}\n}\n\nfunction mapArray(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ArrayTypeNode) => TypeNode,\n): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'unknown') {\n      return base\n    }\n    if (base.type === 'array') {\n      return mapper(base)\n    }\n    return {type: 'null'}\n  })\n}\n\nfunction mapObject(\n  node: TypeNode,\n  scope: Scope,\n  mapper: (node: ObjectTypeNode) => TypeNode,\n): TypeNode {\n  return mapNode(node, scope, (base) => {\n    if (base.type === 'unknown') {\n      return base\n    }\n    if (base.type === 'object') {\n      return mapper(base)\n    }\n    return {type: 'null'}\n  })\n}\n"],"names":["string","text","flatMap","tokens","patterns","executeAsync","map","node","array","value","Scope","arg","innerResult","terms","parse","rhs","identLen","rawParse","match","of","arrayArg","sepArg","arg1","arg2","typeNode","$trace","attributeNode","base","inner"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41],"debugId":null}}]
}