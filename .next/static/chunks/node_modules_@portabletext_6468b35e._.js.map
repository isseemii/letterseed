{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 7, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/toolkit/src/asserters.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/toolkit/src/sortMarksByOccurences.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/toolkit/src/buildMarksTree.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/toolkit/src/nestLists.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/toolkit/src/spanToPlainText.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/toolkit/src/toPlainText.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/toolkit/src/types.ts"],"sourcesContent":["import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan,\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject,\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      !node.markDefs ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject,\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList,\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan,\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode,\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n","import type {PortableTextSpan, TypedObject} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[],\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U,\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\n\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>,\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children} = block\n  const markDefs = block.markDefs ?? []\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs?.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text})),\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n","import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\n\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct',\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html',\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html',\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode,\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList,\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode,\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>,\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n","import {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\nimport type {ToolkitNestedPortableTextSpan} from './types'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n","import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\n\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /\\s$/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[],\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n","import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition,\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (\n    | ToolkitTextNode\n    | ToolkitNestedPortableTextSpan<PortableTextMarkDefinition>\n    | ArbitraryTypedObject\n  )[]\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6],"debugId":null}},
    {"offset": {"line": 235, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/react/src/components/list.tsx","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/react/src/components/marks.tsx","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/react/src/warnings.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/react/src/components/unknown.tsx","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/react/src/components/defaults.tsx","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/react/src/components/merge.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/react/src/react-portable-text.tsx"],"sourcesContent":["import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n","import type {TypedObject} from '@portabletext/types'\n\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  'em': ({children}) => <em>{children}</em>,\n  'strong': ({children}) => <strong>{children}</strong>,\n  'code': ({children}) => <code>{children}</code>,\n  'underline': ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  console.warn(message)\n}\n","import type {PortableTextReactComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {JSX} from 'react'\n\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): JSX.Element => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextComponents, PortableTextReactComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n): PortableTextReactComponents {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {block, list, listItem, marks, types, ...rest} = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from '@portabletext/toolkit'\nimport {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  LIST_NEST_MODE_HTML,\n  nestLists,\n  spanToPlainText,\n} from '@portabletext/toolkit'\nimport type {\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\nimport {type JSX, type ReactNode, useMemo} from 'react'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>): JSX.Element {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent],\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (hasCustomComponentForNode(node)) {\n      return renderCustomBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderUnknownType(node, index, key, isInline)\n  }\n\n  function hasCustomComponentForNode(node: TypedObject): boolean {\n    return node._type in components.types\n  }\n\n  /* eslint-disable react/jsx-no-bind */\n  function renderListItem(\n    node: PortableTextListItemBlock<PortableTextMarkDefinition, PortableTextSpan>,\n    index: number,\n    key: string,\n  ) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {listItem, ...blockNode} = node\n      children = renderNode({node: blockNode, index, isInline: false, renderNode})\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {nodeType: 'listStyle', type: style})\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode}),\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {nodeType: 'mark', type: markType})\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderUnknownType(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {nodeType: 'block', type: node._type})\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    const Node = components.types[node._type]\n    return Node ? <Node key={key} {...nodeOptions} /> : null\n  }\n  /* eslint-enable react/jsx-no-bind */\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6],"debugId":null}},
    {"offset": {"line": 541, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/schema/src/compile-schema.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/schema/src/define-schema.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/schema/src/types.ts"],"sourcesContent":["import type {SchemaDefinition} from './define-schema'\nimport type {FieldDefinition, Schema} from './schema'\n\n/**\n * @public\n */\nexport function compileSchema(definition: SchemaDefinition): Schema {\n  const styles = (definition.styles ?? []).map((style) => ({\n    ...style,\n    value: style.name,\n  }))\n\n  const blockFields: Array<FieldDefinition> = []\n\n  if (definition.block?.fields) {\n    for (const field of definition.block.fields) {\n      if (\n        field.name === '_type' ||\n        field.name === '_key' ||\n        field.name === 'children' ||\n        field.name === 'markDefs' ||\n        field.name === 'style' ||\n        field.name === 'listItem' ||\n        field.name === 'level'\n      ) {\n        console.warn(\n          `\"${field.name}\" is a reserved field name on Portable Text blocks`,\n        )\n        continue\n      }\n\n      blockFields.push(field)\n    }\n  }\n\n  return {\n    block: {\n      name: definition.block?.name ?? 'block',\n      ...(blockFields.length > 0 ? {fields: blockFields} : {}),\n    },\n    span: {\n      name: 'span',\n    },\n    styles: !styles.some((style) => style.value === 'normal')\n      ? [{value: 'normal', name: 'normal', title: 'Normal'}, ...styles]\n      : styles,\n    lists: (definition.lists ?? []).map((list) => ({\n      ...list,\n      value: list.name,\n    })),\n    decorators: (definition.decorators ?? []).map((decorator) => ({\n      ...decorator,\n      value: decorator.name,\n    })),\n    annotations: (definition.annotations ?? []).map((annotation) => ({\n      ...annotation,\n      fields: annotation.fields ?? [],\n    })),\n    blockObjects: (definition.blockObjects ?? []).map((blockObject) => ({\n      ...blockObject,\n      fields: blockObject.fields ?? [],\n    })),\n    inlineObjects: (definition.inlineObjects ?? []).map((inlineObject) => ({\n      ...inlineObject,\n      fields: inlineObject.fields ?? [],\n    })),\n  }\n}\n","import type {BaseDefinition, FieldDefinition} from './schema'\n\n/**\n * @public\n */\nexport type SchemaDefinition = {\n  block?: {\n    name?: string\n    fields?: ReadonlyArray<FieldDefinition>\n  }\n  styles?: ReadonlyArray<StyleDefinition>\n  lists?: ReadonlyArray<ListDefinition>\n  decorators?: ReadonlyArray<DecoratorDefinition>\n  annotations?: ReadonlyArray<AnnotationDefinition>\n  blockObjects?: ReadonlyArray<BlockObjectDefinition>\n  inlineObjects?: ReadonlyArray<InlineObjectDefinition>\n}\n\n/**\n * @public\n * A helper wrapper that adds editor support, such as autocomplete and type checking, for a schema definition.\n * @example\n * ```ts\n * import { defineSchema } from '@portabletext/editor'\n *\n * const schemaDefinition = defineSchema({\n *  decorators: [{name: 'strong'}, {name: 'em'}, {name: 'underline'}],\n *  annotations: [{name: 'link'}],\n *  styles: [\n *    {name: 'normal'},\n *    {name: 'h1'},\n *    {name: 'h2'},\n *    {name: 'h3'},\n *    {name: 'blockquote'},\n *  ],\n *  lists: [],\n *  inlineObjects: [],\n *  blockObjects: [],\n * }\n * ```\n */\nexport function defineSchema<const TSchemaDefinition extends SchemaDefinition>(\n  definition: TSchemaDefinition,\n): TSchemaDefinition {\n  return definition\n}\n\n/**\n * @public\n */\nexport type StyleDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type ListDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type DecoratorDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition\n\n/**\n * @public\n */\nexport type AnnotationDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type BlockObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n\n/**\n * @public\n */\nexport type InlineObjectDefinition<\n  TBaseDefinition extends BaseDefinition = BaseDefinition,\n> = TBaseDefinition & {\n  fields?: ReadonlyArray<FieldDefinition>\n}\n","import type {Schema} from './schema'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  [key: string]: unknown\n  _type: string\n}\n\n/**\n * @public\n */\nexport function isTypedObject(object: unknown): object is TypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\n/**\n * @public\n */\nexport type PortableTextBlock = PortableTextTextBlock | PortableTextObject\n\n/**\n * @public\n */\nexport interface PortableTextTextBlock<\n  TChild = PortableTextSpan | PortableTextObject,\n> {\n  _type: string\n  _key: string\n  children: TChild[]\n  markDefs?: PortableTextObject[]\n  listItem?: string\n  style?: string\n  level?: number\n}\n\n/**\n * @public\n */\nexport function isTextBlock(\n  context: {schema: Schema},\n  block: unknown,\n): block is PortableTextTextBlock {\n  if (!isTypedObject(block)) {\n    return false\n  }\n\n  if (block._type !== context.schema.block.name) {\n    return false\n  }\n\n  if (!Array.isArray(block.children)) {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextSpan {\n  _key: string\n  _type: 'span'\n  text: string\n  marks?: string[]\n}\n\n/**\n * @public\n */\nexport function isSpan(\n  context: {schema: Schema},\n  child: unknown,\n): child is PortableTextSpan {\n  if (!isTypedObject(child)) {\n    return false\n  }\n\n  if (child._type !== context.schema.span.name) {\n    return false\n  }\n\n  if (typeof child.text !== 'string') {\n    return false\n  }\n\n  return true\n}\n\n/**\n * @public\n */\nexport interface PortableTextObject {\n  _type: string\n  _key: string\n  [other: string]: unknown\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2],"debugId":null}},
    {"offset": {"line": 623, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/sanity-bridge/src/portable-text-member-schema-types.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/sanity-bridge/src/portable-text-member-schema-types-to-schema.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/sanity-bridge/src/sanity-schema-to-portable-text-schema.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/sanity-bridge/src/key-generator.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/sanity-bridge/src/schema-definition-to-portable-text-member-schema-types.ts"],"sourcesContent":["import type {\n  ArraySchemaType,\n  BlockDecoratorDefinition,\n  BlockListDefinition,\n  BlockSchemaType,\n  BlockStyleDefinition,\n  ObjectSchemaType,\n  PortableTextBlock,\n  SchemaType,\n  SpanSchemaType,\n} from '@sanity/types'\n\n/**\n * @public\n * Sanity-specific schema types for Portable Text.\n */\nexport type PortableTextMemberSchemaTypes = {\n  annotations: (ObjectSchemaType & {i18nTitleKey?: string})[]\n  block: ObjectSchemaType\n  blockObjects: ObjectSchemaType[]\n  decorators: BlockDecoratorDefinition[]\n  inlineObjects: ObjectSchemaType[]\n  portableText: ArraySchemaType<PortableTextBlock>\n  span: ObjectSchemaType\n  styles: BlockStyleDefinition[]\n  lists: BlockListDefinition[]\n}\n\n/**\n * @public\n * Create Sanity-specific schema types for Portable Text from a Sanity array\n * schema type.\n */\nexport function createPortableTextMemberSchemaTypes(\n  portableTextType: ArraySchemaType<PortableTextBlock>,\n): PortableTextMemberSchemaTypes {\n  if (!portableTextType) {\n    throw new Error(\"Parameter 'portabletextType' missing (required)\")\n  }\n  const blockType = portableTextType.of?.find(findBlockType) as\n    | BlockSchemaType\n    | undefined\n  if (!blockType) {\n    throw new Error('Block type is not defined in this schema (required)')\n  }\n  const childrenField = blockType.fields?.find(\n    (field) => field.name === 'children',\n  ) as {type: ArraySchemaType} | undefined\n  if (!childrenField) {\n    throw new Error('Children field for block type found in schema (required)')\n  }\n  const ofType = childrenField.type.of\n  if (!ofType) {\n    throw new Error(\n      'Valid types for block children not found in schema (required)',\n    )\n  }\n  const spanType = ofType.find((memberType) => memberType.name === 'span') as\n    | ObjectSchemaType\n    | undefined\n  if (!spanType) {\n    throw new Error('Span type not found in schema (required)')\n  }\n  const inlineObjectTypes = (ofType.filter(\n    (memberType) => memberType.name !== 'span',\n  ) || []) as ObjectSchemaType[]\n  const blockObjectTypes = (portableTextType.of?.filter(\n    (field) => field.name !== blockType.name,\n  ) || []) as ObjectSchemaType[]\n  return {\n    styles: resolveEnabledStyles(blockType),\n    decorators: resolveEnabledDecorators(spanType),\n    lists: resolveEnabledListItems(blockType),\n    block: blockType,\n    span: spanType,\n    portableText: portableTextType,\n    inlineObjects: inlineObjectTypes,\n    blockObjects: blockObjectTypes,\n    annotations: (spanType as SpanSchemaType).annotations,\n  }\n}\n\nfunction resolveEnabledStyles(blockType: ObjectSchemaType) {\n  const styleField = blockType.fields?.find(\n    (btField) => btField.name === 'style',\n  )\n  if (!styleField) {\n    throw new Error(\n      \"A field with name 'style' is not defined in the block type (required).\",\n    )\n  }\n  const textStyles =\n    styleField.type.options?.list &&\n    styleField.type.options.list?.filter(\n      (style: {value: string}) => style.value,\n    )\n  if (!textStyles || textStyles.length === 0) {\n    throw new Error(\n      'The style fields need at least one style ' +\n        \"defined. I.e: {title: 'Normal', value: 'normal'}.\",\n    )\n  }\n  return textStyles\n}\n\nfunction resolveEnabledDecorators(spanType: ObjectSchemaType) {\n  return (spanType as any).decorators\n}\n\nfunction resolveEnabledListItems(blockType: ObjectSchemaType) {\n  const listField = blockType.fields?.find(\n    (btField) => btField.name === 'listItem',\n  )\n  if (!listField) {\n    throw new Error(\n      \"A field with name 'listItem' is not defined in the block type (required).\",\n    )\n  }\n  const listItems =\n    listField.type.options?.list &&\n    listField.type.options.list.filter((list: {value: string}) => list.value)\n  if (!listItems) {\n    throw new Error('The list field need at least to be an empty array')\n  }\n  return listItems\n}\n\nfunction findBlockType(type: SchemaType): BlockSchemaType | null {\n  if (type.type) {\n    return findBlockType(type.type)\n  }\n\n  if (type.name === 'block') {\n    return type as BlockSchemaType\n  }\n\n  return null\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {PortableTextMemberSchemaTypes} from './portable-text-member-schema-types'\n\n/**\n * @public\n * Convert Sanity-specific schema types for Portable Text to a first-class\n * Portable Text schema.\n */\nexport function portableTextMemberSchemaTypesToSchema(\n  schema: PortableTextMemberSchemaTypes,\n): Schema {\n  return {\n    annotations: schema.annotations.map((annotation) => ({\n      name: annotation.name,\n      fields: annotation.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: annotation.title,\n    })),\n    block: {\n      name: schema.block.name,\n    },\n    blockObjects: schema.blockObjects.map((blockObject) => ({\n      name: blockObject.name,\n      fields: blockObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: blockObject.title,\n    })),\n    decorators: schema.decorators.map((decorator) => ({\n      name: decorator.value,\n      title: decorator.title,\n      value: decorator.value,\n    })),\n    inlineObjects: schema.inlineObjects.map((inlineObject) => ({\n      name: inlineObject.name,\n      fields: inlineObject.fields.map((field) => ({\n        name: field.name,\n        type: field.type.jsonType,\n        title: field.type.title,\n      })),\n      title: inlineObject.title,\n    })),\n    span: {\n      name: schema.span.name,\n    },\n    styles: schema.styles.map((style) => ({\n      name: style.value,\n      title: style.title,\n      value: style.value,\n    })),\n    lists: schema.lists.map((list) => ({\n      name: list.value,\n      title: list.title,\n      value: list.value,\n    })),\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {Schema as SanitySchema} from '@sanity/schema'\nimport {builtinTypes} from '@sanity/schema/_internal'\nimport type {ArrayDefinition, ArraySchemaType} from '@sanity/types'\nimport {createPortableTextMemberSchemaTypes} from './portable-text-member-schema-types'\nimport {portableTextMemberSchemaTypesToSchema} from './portable-text-member-schema-types-to-schema'\n\n/**\n * @public\n * Compile a Sanity schema to a Portable Text `Schema`.\n *\n * A Portable Text `Schema` is compatible with a Portable Text\n * `SchemaDefinition` and can be used as configuration for the Portable Text\n * Editor.\n *\n * @example\n * ```tsx\n * const schema = sanitySchemaToPortableTextSchema(sanitySchema)\n *\n * return (\n *   <EditorProvider\n *     initialConfig={{\n *       // ...\n *       schemaDefinition: schema,\n *     }}\n *   >\n *     // ...\n *   </EditorProvider>\n * ```\n */\nexport function sanitySchemaToPortableTextSchema(\n  sanitySchema: ArraySchemaType<unknown> | ArrayDefinition,\n): Schema {\n  const portableTextMemberSchemaTypes = createPortableTextMemberSchemaTypes(\n    sanitySchema.hasOwnProperty('jsonType')\n      ? sanitySchema\n      : compileType(sanitySchema),\n  )\n\n  return portableTextMemberSchemaTypesToSchema(portableTextMemberSchemaTypes)\n}\n\nfunction compileType(rawType: any) {\n  return SanitySchema.compile({\n    name: 'blockTypeSchema',\n    types: [rawType, ...builtinTypes],\n  }).get(rawType.name)\n}\n","import getRandomValues from 'get-random-values-esm'\n\nexport const keyGenerator = (): string => randomKey(12)\n\nconst getByteHexTable = (() => {\n  let table: any[]\n  return () => {\n    if (table) {\n      return table\n    }\n\n    table = []\n    for (let i = 0; i < 256; ++i) {\n      table[i] = (i + 0x100).toString(16).slice(1)\n    }\n    return table\n  }\n})()\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nfunction randomKey(length?: number): string {\n  const table = getByteHexTable()\n  return whatwgRNG(length)\n    .reduce((str, n) => str + table[n], '')\n    .slice(0, length)\n}\n","import type {SchemaDefinition} from '@portabletext/schema'\nimport {Schema as SanitySchema} from '@sanity/schema'\nimport {\n  defineField,\n  defineType,\n  isArraySchemaType,\n  isObjectSchemaType,\n  type ObjectSchemaType,\n} from '@sanity/types'\nimport startCase from 'lodash.startcase'\nimport {keyGenerator} from './key-generator'\nimport {\n  createPortableTextMemberSchemaTypes,\n  type PortableTextMemberSchemaTypes,\n} from './portable-text-member-schema-types'\n\nconst temporaryImageBlockObjectName = `tmp-${keyGenerator()}-image`\nconst temporaryUrlBlockObjectName = `tmp-${keyGenerator()}-url`\nconst temporaryImageInlineObjectName = `tmp-${keyGenerator()}-image`\nconst temporaryUrlInlineObjectName = `tmp-${keyGenerator()}-url`\n\nconst temporaryBlockObjectNames: Record<string, string> = {\n  image: temporaryImageBlockObjectName,\n  url: temporaryUrlBlockObjectName,\n}\n\nconst temporaryInlineObjectNames: Record<string, string> = {\n  image: temporaryImageInlineObjectName,\n  url: temporaryUrlInlineObjectName,\n}\n\nconst blockObjectNames: Record<string, string> = {\n  [temporaryImageBlockObjectName]: 'image',\n  [temporaryUrlBlockObjectName]: 'url',\n}\n\nconst inlineObjectNames: Record<string, string> = {\n  [temporaryImageInlineObjectName]: 'image',\n  [temporaryUrlInlineObjectName]: 'url',\n}\n\nconst defaultObjectTitles: Record<string, string> = {\n  image: 'Image',\n  url: 'URL',\n}\n\n/**\n * @public\n * Compile a Portable Text schema definition to Sanity-specific schema types for\n * Portable Text.\n */\nexport function compileSchemaDefinitionToPortableTextMemberSchemaTypes(\n  definition?: SchemaDefinition,\n): PortableTextMemberSchemaTypes {\n  const blockObjects =\n    definition?.blockObjects?.map((blockObject) =>\n      defineType({\n        type: 'object',\n        // Very naive way to work around `SanitySchema.compile` adding default\n        // fields to objects with certain names.\n        name: temporaryBlockObjectNames[blockObject.name] ?? blockObject.name,\n        title:\n          blockObject.title === undefined\n            ? // This avoids the default title which is a title case of the object name\n              defaultObjectTitles[blockObject.name]\n            : blockObject.title,\n        fields:\n          blockObject.fields?.map((field) => ({\n            name: field.name,\n            type: field.type,\n            title: field.title ?? startCase(field.name),\n          })) ?? [],\n      }),\n    ) ?? []\n\n  const inlineObjects =\n    definition?.inlineObjects?.map((inlineObject) =>\n      defineType({\n        type: 'object',\n        // Very naive way to work around `SanitySchema.compile` adding default\n        // fields to objects with certain names.\n        name:\n          temporaryInlineObjectNames[inlineObject.name] ?? inlineObject.name,\n\n        title:\n          inlineObject.title === undefined\n            ? // This avoids the default title which is a title case of the object name\n              defaultObjectTitles[inlineObject.name]\n            : inlineObject.title,\n        fields:\n          inlineObject.fields?.map((field) => ({\n            name: field.name,\n            type: field.type,\n            title: field.title ?? startCase(field.name),\n          })) ?? [],\n      }),\n    ) ?? []\n\n  const portableTextSchema = defineField({\n    type: 'array',\n    name: 'portable-text',\n    of: [\n      ...blockObjects.map((blockObject) => ({type: blockObject.name})),\n      {\n        type: 'block',\n        name: 'block',\n        of: inlineObjects.map((inlineObject) => ({type: inlineObject.name})),\n        marks: {\n          decorators:\n            definition?.decorators?.map((decorator) => ({\n              title: decorator.title ?? startCase(decorator.name),\n              value: decorator.name,\n            })) ?? [],\n          annotations:\n            definition?.annotations?.map((annotation) => ({\n              name: annotation.name,\n              type: 'object',\n              title: annotation.title,\n              fields:\n                annotation.fields?.map((field) => ({\n                  name: field.name,\n                  title: field.title ?? startCase(field.name),\n                  type: field.type,\n                })) ?? [],\n            })) ?? [],\n        },\n        lists:\n          definition?.lists?.map((list) => ({\n            value: list.name,\n            title: list.title ?? startCase(list.name),\n          })) ?? [],\n        styles:\n          definition?.styles?.map((style) => ({\n            value: style.name,\n            title: style.title ?? startCase(style.name),\n          })) ?? [],\n      },\n    ],\n  })\n\n  const schema = SanitySchema.compile({\n    types: [portableTextSchema, ...blockObjects, ...inlineObjects],\n  }).get('portable-text')\n\n  const pteSchema = createPortableTextMemberSchemaTypes(schema)\n\n  return {\n    ...pteSchema,\n    portableText: {\n      ...pteSchema.portableText,\n      of: pteSchema.portableText.of.map((schemaType) => {\n        if (!isObjectSchemaType(schemaType)) {\n          return schemaType\n        }\n\n        const nameMapping = blockObjectNames[schemaType.name]\n\n        schemaType.name = nameMapping ?? schemaType.name\n\n        for (const field of schemaType.fields) {\n          if (field.name !== 'children' || !isArraySchemaType(field.type)) {\n            continue\n          }\n\n          for (const ofSchemaType of field.type.of) {\n            const nameMapping = inlineObjectNames[ofSchemaType.name]\n\n            if (!nameMapping) {\n              continue\n            }\n\n            ofSchemaType.name = nameMapping\n          }\n        }\n\n        return schemaType\n      }),\n    },\n    blockObjects: pteSchema.blockObjects.map((blockObject) =>\n      blockObjectNames[blockObject.name] !== undefined\n        ? ({\n            ...blockObject,\n            name: blockObjectNames[blockObject.name],\n            type: {\n              ...blockObject.type,\n              name: blockObjectNames[blockObject.name],\n            },\n          } as ObjectSchemaType)\n        : blockObject,\n    ),\n    inlineObjects: pteSchema.inlineObjects.map((inlineObject) =>\n      inlineObjectNames[inlineObject.name] !== undefined\n        ? ({\n            ...inlineObject,\n            name: inlineObjectNames[inlineObject.name],\n          } as ObjectSchemaType)\n        : inlineObject,\n    ),\n  } satisfies PortableTextMemberSchemaTypes\n}\n"],"names":["SanitySchema","nameMapping"],"mappings":"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","ignoreList":[0,1,2,3,4],"debugId":null}},
    {"offset": {"line": 888, "column": 0}, "map": {"version":3,"file":"helpers.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/util/resolveJsType.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/types.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/flatten-nested-blocks.ts","file:///Users/isseemii/app/letterseed/node_modules/node_modules/.pnpm/%40vercel%2Bstega%400.1.2/node_modules/%40vercel/stega/dist/index.mjs","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/constants.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/xpathResult.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/gdocs.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/html.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/notion.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/whitespace.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/word.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/preprocessors/index.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/helpers.ts"],"sourcesContent":["const objectToString = Object.prototype.toString\n\n// Copied from https://github.com/ForbesLindesay/type-of\n// but inlined to have fine grained control\nexport function resolveJsType(val: unknown) {\n  switch (objectToString.call(val)) {\n    case '[object Function]':\n      return 'function'\n    case '[object Date]':\n      return 'date'\n    case '[object RegExp]':\n      return 'regexp'\n    case '[object Arguments]':\n      return 'arguments'\n    case '[object Array]':\n      return 'array'\n    case '[object String]':\n      return 'string'\n    default:\n  }\n\n  if (val === null) {\n    return 'null'\n  }\n\n  if (val === undefined) {\n    return 'undefined'\n  }\n\n  if (\n    val &&\n    typeof val === 'object' &&\n    'nodeType' in val &&\n    (val as {nodeType: unknown}).nodeType === 1\n  ) {\n    return 'element'\n  }\n\n  if (val === Object(val)) {\n    return 'object'\n  }\n\n  return typeof val\n}\n","import type {PortableTextObject} from '@portabletext/schema'\nimport type {SchemaMatchers} from './schema-matchers'\n\n/**\n * @public\n */\nexport interface TypedObject {\n  _type: string\n  _key?: string\n}\n\n/**\n * @public\n */\nexport interface ArbitraryTypedObject extends TypedObject {\n  [key: string]: unknown\n}\n\nexport function isArbitraryTypedObject(\n  object: unknown,\n): object is ArbitraryTypedObject {\n  return isRecord(object) && typeof object._type === 'string'\n}\n\nfunction isRecord(value: unknown): value is Record<string, unknown> {\n  return !!value && (typeof value === 'object' || typeof value === 'function')\n}\n\nexport interface MinimalSpan {\n  _type: 'span'\n  _key?: string\n  text: string\n  marks?: string[]\n}\n\nexport interface MinimalBlock extends TypedObject {\n  _type: 'block'\n  children: TypedObject[]\n  markDefs?: TypedObject[]\n  style?: string\n  level?: number\n  listItem?: string\n}\n\nexport interface PlaceholderDecorator {\n  _type: '__decorator'\n  name: string\n  children: TypedObject[]\n}\n\nexport interface PlaceholderAnnotation {\n  _type: '__annotation'\n  markDef: PortableTextObject\n  children: TypedObject[]\n}\n\n/**\n * @public\n */\nexport type HtmlParser = (html: string) => Document\n\n/**\n * @public\n */\nexport type WhiteSpacePasteMode = 'preserve' | 'remove' | 'normalize'\n\n/**\n * @public\n */\nexport interface HtmlDeserializerOptions {\n  keyGenerator?: () => string\n  rules?: DeserializerRule[]\n  parseHtml?: HtmlParser\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n  /**\n   * Custom schema matchers to use when deserializing HTML to Portable Text.\n   * @beta\n   */\n  matchers?: SchemaMatchers\n}\n\nexport interface HtmlPreprocessorOptions {\n  unstable_whitespaceOnPasteMode?: WhiteSpacePasteMode\n}\n\n/**\n * @public\n */\nexport interface DeserializerRule {\n  deserialize: (\n    el: Node,\n    next: (\n      elements: Node | Node[] | NodeList,\n    ) => TypedObject | TypedObject[] | undefined,\n    createBlock: (props: ArbitraryTypedObject) => {\n      _type: string\n      block: ArbitraryTypedObject\n    },\n  ) => TypedObject | TypedObject[] | undefined\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqual} from 'lodash'\nimport {\n  isArbitraryTypedObject,\n  type ArbitraryTypedObject,\n  type TypedObject,\n} from '../types'\n\nexport function flattenNestedBlocks(\n  context: {\n    schema: Schema\n  },\n  blocks: Array<ArbitraryTypedObject>,\n): TypedObject[] {\n  const flattened = blocks.flatMap((block) => {\n    if (isBlockContainer(block)) {\n      return flattenNestedBlocks(context, [block.block])\n    }\n\n    if (isTextBlock(context, block)) {\n      const hasBlockObjects = block.children.some((child) => {\n        const knownBlockObject = context.schema.blockObjects.some(\n          (blockObject) => blockObject.name === child._type,\n        )\n        return knownBlockObject\n      })\n      const hasBlocks = block.children.some(\n        (child) => child._type === '__block' || child._type === 'block',\n      )\n\n      if (hasBlockObjects || hasBlocks) {\n        const splitChildren = getSplitChildren(context, block)\n\n        if (\n          splitChildren.length === 1 &&\n          splitChildren[0].type === 'children' &&\n          isEqual(splitChildren[0].children, block.children)\n        ) {\n          return [block]\n        }\n\n        return splitChildren.flatMap((slice) => {\n          if (slice.type === 'block object') {\n            return [slice.block]\n          }\n\n          if (slice.type === 'block') {\n            return flattenNestedBlocks(context, [\n              slice.block as ArbitraryTypedObject,\n            ])\n          }\n\n          if (slice.children.length > 0) {\n            if (\n              slice.children.every(\n                (child) => isSpan(context, child) && child.text.trim() === '',\n              )\n            ) {\n              return []\n            }\n\n            return flattenNestedBlocks(context, [\n              {\n                ...block,\n                children: slice.children,\n              },\n            ])\n          }\n\n          return []\n        })\n      }\n\n      return [block]\n    }\n\n    return [block]\n  })\n\n  return flattened\n}\n\nfunction isBlockContainer(\n  block: ArbitraryTypedObject,\n): block is BlockContainer {\n  return block._type === '__block' && isArbitraryTypedObject(block.block)\n}\n\ntype BlockContainer = {\n  _type: '__block'\n  block: ArbitraryTypedObject\n}\n\nfunction getSplitChildren(\n  context: {schema: Schema},\n  block: PortableTextTextBlock,\n) {\n  return block.children.reduce(\n    (slices, child) => {\n      const knownInlineObject = context.schema.inlineObjects.some(\n        (inlineObject) => inlineObject.name === child._type,\n      )\n      const knownBlockObject = context.schema.blockObjects.some(\n        (blockObject) => blockObject.name === child._type,\n      )\n\n      const lastSlice = slices.pop()\n\n      if (!isSpan(context, child) && !knownInlineObject) {\n        if (knownBlockObject) {\n          return [\n            ...slices,\n            ...(lastSlice ? [lastSlice] : []),\n            {type: 'block object' as const, block: child},\n          ]\n        }\n      }\n\n      if (child._type === '__block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {\n            type: 'block object' as const,\n            block: (child as any).block,\n          },\n        ]\n      }\n\n      if (child._type === 'block') {\n        return [\n          ...slices,\n          ...(lastSlice ? [lastSlice] : []),\n          {type: 'block' as const, block: child},\n        ]\n      }\n\n      if (lastSlice) {\n        if (lastSlice.type === 'children') {\n          return [\n            ...slices,\n            {\n              type: 'children' as const,\n              children: [...lastSlice.children, child],\n            },\n          ]\n        }\n      }\n\n      return [\n        ...slices,\n        ...(lastSlice ? [lastSlice] : []),\n        {type: 'children' as const, children: [child]},\n      ]\n    },\n    [] as Array<\n      | {\n          type: 'children'\n          children: Array<PortableTextSpan | PortableTextObject>\n        }\n      | {type: 'block object'; block: PortableTextObject}\n      | {type: 'block'; block: PortableTextBlock}\n    >,\n  )\n}\n","var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {uniq} from 'lodash'\n\nexport interface PartialBlock {\n  _type: string\n  markDefs: string[]\n  style: string\n  level?: number\n  listItem?: string\n}\n\nexport const PRESERVE_WHITESPACE_TAGS = ['pre', 'textarea', 'code']\n\nexport const BLOCK_DEFAULT_STYLE = 'normal'\n\nexport const DEFAULT_BLOCK: PartialBlock = Object.freeze({\n  _type: 'block',\n  markDefs: [],\n  style: BLOCK_DEFAULT_STYLE,\n})\n\nexport const DEFAULT_SPAN = Object.freeze({\n  _type: 'span',\n  marks: [] as string[],\n})\n\nexport const HTML_BLOCK_TAGS = {\n  p: DEFAULT_BLOCK,\n  blockquote: {...DEFAULT_BLOCK, style: 'blockquote'} as PartialBlock,\n}\n\nexport const HTML_SPAN_TAGS = {\n  span: {object: 'text'},\n}\n\nexport const HTML_LIST_CONTAINER_TAGS: Record<\n  string,\n  {object: null} | undefined\n> = {\n  ol: {object: null},\n  ul: {object: null},\n}\n\nexport const HTML_HEADER_TAGS: Record<string, PartialBlock | undefined> = {\n  h1: {...DEFAULT_BLOCK, style: 'h1'},\n  h2: {...DEFAULT_BLOCK, style: 'h2'},\n  h3: {...DEFAULT_BLOCK, style: 'h3'},\n  h4: {...DEFAULT_BLOCK, style: 'h4'},\n  h5: {...DEFAULT_BLOCK, style: 'h5'},\n  h6: {...DEFAULT_BLOCK, style: 'h6'},\n}\n\nexport const HTML_MISC_TAGS = {\n  br: {...DEFAULT_BLOCK, style: BLOCK_DEFAULT_STYLE} as PartialBlock,\n}\n\nexport const HTML_DECORATOR_TAGS: Record<string, string | undefined> = {\n  b: 'strong',\n  strong: 'strong',\n\n  i: 'em',\n  em: 'em',\n\n  u: 'underline',\n  s: 'strike-through',\n  strike: 'strike-through',\n  del: 'strike-through',\n\n  code: 'code',\n  sup: 'sup',\n  sub: 'sub',\n  ins: 'ins',\n  mark: 'mark',\n  small: 'small',\n}\n\nexport const HTML_LIST_ITEM_TAGS: Record<string, PartialBlock | undefined> = {\n  li: {\n    ...DEFAULT_BLOCK,\n    style: BLOCK_DEFAULT_STYLE,\n    level: 1,\n    listItem: 'bullet',\n  },\n}\n\nexport const ELEMENT_MAP = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_SPAN_TAGS,\n  ...HTML_LIST_CONTAINER_TAGS,\n  ...HTML_LIST_ITEM_TAGS,\n  ...HTML_HEADER_TAGS,\n  ...HTML_MISC_TAGS,\n}\n\nexport const DEFAULT_SUPPORTED_STYLES = uniq(\n  Object.values(ELEMENT_MAP)\n    .filter((tag): tag is PartialBlock => 'style' in tag)\n    .map((tag) => tag.style),\n)\n\nexport const DEFAULT_SUPPORTED_DECORATORS = uniq(\n  Object.values(HTML_DECORATOR_TAGS),\n)\n\nexport const DEFAULT_SUPPORTED_ANNOTATIONS = ['link']\n","// We need this here if run server side\nexport const _XPathResult = {\n  ANY_TYPE: 0,\n  NUMBER_TYPE: 1,\n  STRING_TYPE: 2,\n  BOOLEAN_TYPE: 3,\n  UNORDERED_NODE_ITERATOR_TYPE: 4,\n  ORDERED_NODE_ITERATOR_TYPE: 5,\n  UNORDERED_NODE_SNAPSHOT_TYPE: 6,\n  ORDERED_NODE_SNAPSHOT_TYPE: 7,\n  ANY_UNORDERED_NODE_TYPE: 8,\n  FIRST_ORDERED_NODE_TYPE: 9,\n}\n","import type {HtmlPreprocessorOptions} from '../../types'\nimport {normalizeWhitespace, removeAllWhitespace, tagName} from '../helpers'\nimport {_XPathResult} from './xpathResult'\n\nexport default (\n  _html: string,\n  doc: Document,\n  options: HtmlPreprocessorOptions,\n): Document => {\n  const whitespaceOnPasteMode =\n    options?.unstable_whitespaceOnPasteMode || 'preserve'\n  let gDocsRootOrSiblingNode = doc\n    .evaluate(\n      '//*[@id and contains(@id, \"docs-internal-guid\")]',\n      doc,\n      null,\n      _XPathResult.ORDERED_NODE_ITERATOR_TYPE,\n      null,\n    )\n    .iterateNext()\n\n  if (gDocsRootOrSiblingNode) {\n    const isWrappedRootTag = tagName(gDocsRootOrSiblingNode) === 'b'\n\n    // If this document isn't wrapped in a 'b' tag, then assume all siblings live on the root level\n    if (!isWrappedRootTag) {\n      gDocsRootOrSiblingNode = doc.body\n    }\n\n    switch (whitespaceOnPasteMode) {\n      case 'normalize':\n        // Keep only 1 empty block between content nodes\n        normalizeWhitespace(gDocsRootOrSiblingNode)\n        break\n      case 'remove':\n        // Remove all whitespace nodes\n        removeAllWhitespace(gDocsRootOrSiblingNode)\n        break\n      default:\n        break\n    }\n\n    // Tag every child with attribute 'is-google-docs' so that the GDocs rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-google-docs', 'true')\n\n      if (\n        elm?.parentElement === gDocsRootOrSiblingNode ||\n        (!isWrappedRootTag && elm.parentElement === doc.body)\n      ) {\n        elm?.setAttribute('data-is-root-node', 'true')\n        tagName(elm)\n      }\n\n      // Handle checkmark lists - The first child of a list item is an image with a checkmark, and the serializer\n      // expects the first child to be the text node\n      if (\n        tagName(elm) === 'li' &&\n        elm.firstChild &&\n        tagName(elm?.firstChild) === 'img'\n      ) {\n        elm.removeChild(elm.firstChild)\n      }\n    }\n\n    // Remove that 'b' which Google Docs wraps the HTML content in\n    if (isWrappedRootTag) {\n      doc.body.firstElementChild?.replaceWith(\n        ...Array.from(gDocsRootOrSiblingNode.childNodes),\n      )\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\n// Remove this cruft from the document\nconst unwantedWordDocumentPaths = [\n  '/html/text()',\n  '/html/head/text()',\n  '/html/body/text()',\n  '/html/body/ul/text()',\n  '/html/body/ol/text()',\n  '//comment()',\n  '//style',\n  '//xml',\n  '//script',\n  '//meta',\n  '//link',\n]\n\nexport default (_html: string, doc: Document): Document => {\n  // Make sure text directly on the body is wrapped in spans.\n  // This mimics what the browser does before putting html on the clipboard,\n  // when used in a script context with JSDOM\n  const bodyTextNodes = doc.evaluate(\n    '/html/body/text()',\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = bodyTextNodes.snapshotLength - 1; i >= 0; i--) {\n    const node = bodyTextNodes.snapshotItem(i) as HTMLElement\n    const text = node.textContent || ''\n    if (text.replace(/[^\\S\\n]+$/g, '')) {\n      const newNode = doc.createElement('span')\n      newNode.appendChild(doc.createTextNode(text))\n      node.parentNode?.replaceChild(newNode, node)\n    } else {\n      node.parentNode?.removeChild(node)\n    }\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedWordDocumentPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (!unwanted) {\n      continue\n    }\n    unwanted.parentNode?.removeChild(unwanted)\n  }\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nexport default (html: string, doc: Document): Document => {\n  const NOTION_REGEX = /<!-- notionvc:.*?-->/g\n\n  if (html.match(NOTION_REGEX)) {\n    // Tag every child with attribute 'is-notion' so that the Notion rule-set can\n    // work exclusivly on these children\n    const childNodes = doc.evaluate(\n      '//*',\n      doc,\n      null,\n      _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n      null,\n    )\n\n    for (let i = childNodes.snapshotLength - 1; i >= 0; i--) {\n      const elm = childNodes.snapshotItem(i) as HTMLElement\n      elm?.setAttribute('data-is-notion', 'true')\n    }\n\n    return doc\n  }\n  return doc\n}\n","import {PRESERVE_WHITESPACE_TAGS} from '../../constants'\nimport {_XPathResult} from './xpathResult'\n\nexport default (_: string, doc: Document): Document => {\n  // Recursively process all nodes.\n  function processNode(node: Node) {\n    // If this is a text node and not inside a tag where whitespace should be preserved, process it.\n    if (\n      node.nodeType === _XPathResult.BOOLEAN_TYPE &&\n      !PRESERVE_WHITESPACE_TAGS.includes(\n        node.parentElement?.tagName.toLowerCase() || '',\n      )\n    ) {\n      node.textContent =\n        node.textContent\n          ?.replace(/\\s\\s+/g, ' ') // Remove multiple whitespace\n          .replace(/[\\r\\n]+/g, ' ') || '' // Replace newlines with spaces\n    }\n    // Otherwise, if this node has children, process them.\n    else {\n      for (let i = 0; i < node.childNodes.length; i++) {\n        processNode(node.childNodes[i])\n      }\n    }\n  }\n\n  // Process all nodes starting from the root.\n  processNode(doc.body)\n\n  return doc\n}\n","import {_XPathResult} from './xpathResult'\n\nconst WORD_HTML_REGEX =\n  /(class=\"?Mso|style=(?:\"|')[^\"]*?\\bmso-|w:WordDocument|<o:\\w+>|<\\/font>)/\n\n// xPaths for elements that will be removed from the document\nconst unwantedPaths = [\n  '//o:p',\n  \"//span[@style='mso-list:Ignore']\",\n  \"//span[@style='mso-list: Ignore']\",\n]\n\n// xPaths for elements that needs to be remapped into other tags\nconst mappedPaths = [\n  \"//p[@class='MsoTocHeading']\",\n  \"//p[@class='MsoTitle']\",\n  \"//p[@class='MsoToaHeading']\",\n  \"//p[@class='MsoSubtitle']\",\n  \"//span[@class='MsoSubtleEmphasis']\",\n  \"//span[@class='MsoIntenseEmphasis']\",\n]\n\n// Which HTML element(s) to map the elements matching mappedPaths into\nconst elementMap: Record<string, string[] | undefined> = {\n  MsoTocHeading: ['h3'],\n  MsoTitle: ['h1'],\n  MsoToaHeading: ['h2'],\n  MsoSubtitle: ['h5'],\n  MsoSubtleEmphasis: ['span', 'em'],\n  MsoIntenseEmphasis: ['span', 'em', 'strong'],\n  // Remove cruft\n}\n\nfunction isWordHtml(html: string) {\n  return WORD_HTML_REGEX.test(html)\n}\n\nexport default (html: string, doc: Document): Document => {\n  if (!isWordHtml(html)) {\n    return doc\n  }\n\n  const unwantedNodes = doc.evaluate(\n    unwantedPaths.join('|'),\n    doc,\n    (prefix) => {\n      if (prefix === 'o') {\n        return 'urn:schemas-microsoft-com:office:office'\n      }\n      return null\n    },\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n\n  for (let i = unwantedNodes.snapshotLength - 1; i >= 0; i--) {\n    const unwanted = unwantedNodes.snapshotItem(i)\n    if (unwanted?.parentNode) {\n      unwanted.parentNode.removeChild(unwanted)\n    }\n  }\n\n  // Transform mapped elements into what they should be mapped to\n  const mappedElements = doc.evaluate(\n    mappedPaths.join('|'),\n    doc,\n    null,\n    _XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE,\n    null,\n  )\n  for (let i = mappedElements.snapshotLength - 1; i >= 0; i--) {\n    const mappedElm = mappedElements.snapshotItem(i) as HTMLElement\n    const tags = elementMap[mappedElm.className]\n    const text = doc.createTextNode(mappedElm.textContent || '')\n    if (!tags) {\n      continue\n    }\n\n    const parentElement = doc.createElement(tags[0])\n    let parent = parentElement\n    let child = parentElement\n    tags.slice(1).forEach((tag) => {\n      child = doc.createElement(tag)\n      parent.appendChild(child)\n      parent = child\n    })\n    child.appendChild(text)\n    mappedElm?.parentNode?.replaceChild(parentElement, mappedElm)\n  }\n\n  return doc\n}\n","import preprocessGDocs from './gdocs'\nimport preprocessHTML from './html'\nimport preprocessNotion from './notion'\nimport preprocessWhitespace from './whitespace'\nimport preprocessWord from './word'\n\nexport default [\n  preprocessWhitespace,\n  preprocessNotion,\n  preprocessWord,\n  preprocessGDocs,\n  preprocessHTML,\n]\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isTextBlock,\n  type PortableTextObject,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {vercelStegaClean} from '@vercel/stega'\nimport {isEqual} from 'lodash'\nimport {DEFAULT_BLOCK} from '../constants'\nimport type {\n  ArbitraryTypedObject,\n  HtmlParser,\n  HtmlPreprocessorOptions,\n  MinimalBlock,\n  MinimalSpan,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {resolveJsType} from '../util/resolveJsType'\nimport preprocessors from './preprocessors'\n\n/**\n * Utility function that always return a lowerCase version of the element.tagName\n *\n * @param el - Element to get tag name for\n * @returns Lowercase tagName for that element, or undefined if not an element\n */\nexport function tagName(el: HTMLElement | Node | null): string | undefined {\n  if (el && 'tagName' in el) {\n    return el.tagName.toLowerCase()\n  }\n\n  return undefined\n}\n\n// TODO: make this plugin-style\nexport function preprocess(\n  html: string,\n  parseHtml: HtmlParser,\n  options: HtmlPreprocessorOptions,\n): Document {\n  const cleanHTML = vercelStegaClean(html)\n  const doc = parseHtml(normalizeHtmlBeforePreprocess(cleanHTML))\n  preprocessors.forEach((processor) => {\n    processor(cleanHTML, doc, options)\n  })\n  return doc\n}\n\nfunction normalizeHtmlBeforePreprocess(html: string): string {\n  return html.trim()\n}\n\n/**\n * A default `parseHtml` function that returns the html using `DOMParser`.\n *\n * @returns HTML Parser based on `DOMParser`\n */\nexport function defaultParseHtml(): HtmlParser {\n  if (resolveJsType(DOMParser) === 'undefined') {\n    throw new Error(\n      'The native `DOMParser` global which the `Html` deserializer uses by ' +\n        'default is not present in this environment. ' +\n        'You must supply the `options.parseHtml` function instead.',\n    )\n  }\n  return (html) => {\n    return new DOMParser().parseFromString(html, 'text/html')\n  }\n}\n\nfunction nextSpan(block: PortableTextTextBlock, index: number) {\n  const next = block.children[index + 1]\n  return next && next._type === 'span' ? next : null\n}\n\nfunction prevSpan(block: PortableTextTextBlock, index: number) {\n  const prev = block.children[index - 1]\n  return prev && prev._type === 'span' ? prev : null\n}\n\nfunction isWhiteSpaceChar(text: string) {\n  return ['\\xa0', ' '].includes(text)\n}\n\n/**\n * NOTE: _mutates_ passed blocks!\n *\n * @param blocks - Array of blocks to trim whitespace for\n * @returns\n */\nexport function trimWhitespace(\n  schema: Schema,\n  blocks: TypedObject[],\n): TypedObject[] {\n  blocks.forEach((block) => {\n    if (!isTextBlock({schema}, block)) {\n      return\n    }\n\n    // eslint-disable-next-line complexity\n    block.children.forEach((child, index) => {\n      if (!isMinimalSpan(child)) {\n        return\n      }\n      const nextChild = nextSpan(block, index)\n      const prevChild = prevSpan(block, index)\n      if (index === 0) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (index === block.children.length - 1) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.slice(Math.max(0, child.text.length - 1))) &&\n        nextChild &&\n        isMinimalSpan(nextChild) &&\n        /\\s/.test(nextChild.text.slice(0, 1))\n      ) {\n        child.text = child.text.replace(/[^\\S\\n]+$/g, '')\n      }\n      if (\n        /\\s/.test(child.text.slice(0, 1)) &&\n        prevChild &&\n        isMinimalSpan(prevChild) &&\n        /\\s/.test(prevChild.text.slice(Math.max(0, prevChild.text.length - 1)))\n      ) {\n        child.text = child.text.replace(/^[^\\S\\n]+/g, '')\n      }\n      if (!child.text) {\n        block.children.splice(index, 1)\n      }\n      if (\n        prevChild &&\n        isEqual(prevChild.marks, child.marks) &&\n        isWhiteSpaceChar(child.text)\n      ) {\n        prevChild.text += ' '\n        block.children.splice(index, 1)\n      } else if (\n        nextChild &&\n        isEqual(nextChild.marks, child.marks) &&\n        isWhiteSpaceChar(child.text)\n      ) {\n        nextChild.text = ` ${nextChild.text}`\n        block.children.splice(index, 1)\n      }\n    })\n  })\n\n  return blocks\n}\n\nexport function ensureRootIsBlocks(\n  schema: Schema,\n  objects: Array<ArbitraryTypedObject>,\n): ArbitraryTypedObject[] {\n  return objects.reduce((blocks, node, i, original) => {\n    if (node._type === 'block') {\n      blocks.push(node)\n      return blocks\n    }\n\n    if (node._type === '__block') {\n      blocks.push((node as any).block)\n      return blocks\n    }\n\n    const lastBlock = blocks[blocks.length - 1]\n    if (\n      i > 0 &&\n      !isTextBlock({schema}, original[i - 1]) &&\n      isTextBlock({schema}, lastBlock)\n    ) {\n      lastBlock.children.push(node as PortableTextObject)\n      return blocks\n    }\n\n    const block = {\n      ...DEFAULT_BLOCK,\n      children: [node],\n    }\n\n    blocks.push(block)\n    return blocks\n  }, [] as ArbitraryTypedObject[])\n}\n\nexport function isNodeList(node: unknown): node is NodeList {\n  return Object.prototype.toString.call(node) === '[object NodeList]'\n}\n\nexport function isMinimalSpan(node: TypedObject): node is MinimalSpan {\n  return node._type === 'span'\n}\n\nexport function isMinimalBlock(node: TypedObject): node is MinimalBlock {\n  return node._type === 'block'\n}\n\nexport function isPlaceholderDecorator(\n  node: TypedObject,\n): node is PlaceholderDecorator {\n  return node._type === '__decorator'\n}\n\nexport function isPlaceholderAnnotation(\n  node: TypedObject,\n): node is PlaceholderAnnotation {\n  return node._type === '__annotation'\n}\n\nexport function isElement(node: Node): node is Element {\n  return node.nodeType === 1\n}\n\n/**\n * Helper to normalize whitespace to only 1 empty block between content nodes\n * @param node - Root node to process\n */\nexport function normalizeWhitespace(rootNode: Node) {\n  let emptyBlockCount = 0\n  let lastParent = null\n  const nodesToRemove: Node[] = []\n\n  for (let child = rootNode.firstChild; child; child = child.nextSibling) {\n    if (!isElement(child)) {\n      normalizeWhitespace(child)\n      emptyBlockCount = 0\n      continue\n    }\n\n    const elm = child as HTMLElement\n\n    if (isWhitespaceBlock(elm)) {\n      if (lastParent && elm.parentElement === lastParent) {\n        emptyBlockCount++\n        if (emptyBlockCount > 1) {\n          nodesToRemove.push(elm)\n        }\n      } else {\n        // Different parent, reset counter\n        emptyBlockCount = 1\n      }\n\n      lastParent = elm.parentElement\n    } else {\n      // Recurse into child nodes\n      normalizeWhitespace(child)\n      // Reset counter for siblings\n      emptyBlockCount = 0\n    }\n  }\n\n  // Remove marked nodes\n  nodesToRemove.forEach((node) => {\n    node.parentElement?.removeChild(node)\n  })\n}\n\n/**\n * Helper to remove all whitespace nodes\n * @param node - Root node to process\n */\nexport function removeAllWhitespace(rootNode: Node) {\n  const nodesToRemove: Node[] = []\n\n  function collectNodesToRemove(currentNode: Node) {\n    if (isElement(currentNode)) {\n      const elm = currentNode as HTMLElement\n\n      // Handle <br> tags that is between <p> tags\n      if (\n        tagName(elm) === 'br' &&\n        (tagName(elm.nextElementSibling) === 'p' ||\n          tagName(elm.previousElementSibling) === 'p')\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Handle empty blocks\n      if (\n        (tagName(elm) === 'p' || tagName(elm) === 'br') &&\n        elm?.firstChild?.textContent?.trim() === ''\n      ) {\n        nodesToRemove.push(elm)\n\n        return\n      }\n\n      // Recursively process child nodes\n      for (let child = elm.firstChild; child; child = child.nextSibling) {\n        collectNodesToRemove(child)\n      }\n    }\n  }\n\n  collectNodesToRemove(rootNode)\n\n  // Remove the collected nodes\n  nodesToRemove.forEach((node) => {\n    node.parentElement?.removeChild(node)\n  })\n}\n\nfunction isWhitespaceBlock(elm: HTMLElement): boolean {\n  return ['p', 'br'].includes(tagName(elm) || '') && !elm.textContent?.trim()\n}\n"],"names":["_","vercelStegaClean"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12],"debugId":null}},
    {"offset": {"line": 1415, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/util/randomKey.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/gdocs.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/whitespace-text-node.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/html.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/notion.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/word.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/rules/index.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/HtmlDeserializer/index.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/util/normalizeBlock.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/block-tools/src/index.ts"],"sourcesContent":["import getRandomValues from 'get-random-values-esm'\n\nexport function keyGenerator() {\n  return randomKey(12)\n}\n\n// WHATWG crypto RNG - https://w3c.github.io/webcrypto/Overview.html\nfunction whatwgRNG(length = 16) {\n  const rnds8 = new Uint8Array(length)\n  getRandomValues(rnds8)\n  return rnds8\n}\n\nconst byteToHex: string[] = []\nfor (let i = 0; i < 256; ++i) {\n  byteToHex[i] = (i + 0x100).toString(16).slice(1)\n}\n\n/**\n * Generate a random key of the given length\n *\n * @param length - Length of string to generate\n * @returns A string of the given length\n * @public\n */\nexport function randomKey(length: number): string {\n  return whatwgRNG(length)\n    .reduce((str, n) => str + byteToHex[n], '')\n    .slice(0, length)\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  BLOCK_DEFAULT_STYLE,\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nconst LIST_CONTAINER_TAGS = Object.keys(HTML_LIST_CONTAINER_TAGS)\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style\\s*:\\s*italic/.test(style || '')\n}\n\n// font-weight:700 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-weight\\s*:\\s*700/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  if (!isElement(el) || tagName(el.parentNode) === 'a') {\n    return false\n  }\n\n  const style = isElement(el) && el.getAttribute('style')\n\n  return /text-decoration\\s*:\\s*underline/.test(style || '')\n}\n\n// text-decoration seems like the most important rule for strike-through in their html\n// allows for line-through regex to be more lineient to allow for other text-decoration before or after\nfunction isStrikethrough(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration\\s*:\\s*(?:.*line-through.*;)/.test(style || '')\n}\n\n// Check for attribute given by the gdocs preprocessor\nfunction isGoogleDocs(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-google-docs'))\n}\n\nfunction isRootNode(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-root-node'))\n}\n\nfunction getListItemStyle(el: Node): 'bullet' | 'number' | undefined {\n  const parentTag = tagName(el.parentNode)\n  if (parentTag && !LIST_CONTAINER_TAGS.includes(parentTag)) {\n    return undefined\n  }\n  return tagName(el.parentNode) === 'ul' ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number {\n  let level = 0\n  if (tagName(el) === 'li') {\n    let parentNode = el.parentNode\n    while (parentNode) {\n      const parentTag = tagName(parentNode)\n      if (parentTag && LIST_CONTAINER_TAGS.includes(parentTag)) {\n        level++\n      }\n      parentNode = parentNode.parentNode\n    }\n  } else {\n    level = 1\n  }\n  return level\n}\n\nconst blocks: Record<string, {style: string} | undefined> = {\n  ...HTML_BLOCK_TAGS,\n  ...HTML_HEADER_TAGS,\n}\n\nfunction getBlockStyle(schema: Schema, el: Node): string {\n  const childTag = tagName(el.firstChild)\n  const block = childTag && blocks[childTag]\n  if (!block) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  if (!schema.styles.some((style) => style.name === block.style)) {\n    return BLOCK_DEFAULT_STYLE\n  }\n  return block.style\n}\n\nexport default function createGDocsRules(schema: Schema): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (isElement(el) && tagName(el) === 'span' && isGoogleDocs(el)) {\n          if (!el.textContent) {\n            if (!el.previousSibling && !el.nextSibling) {\n              el.setAttribute('data-lonely-child', 'true')\n            }\n\n            return next(el.childNodes)\n          }\n\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isStrikethrough(el)) {\n            span.marks.push('strike-through')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'li' && isGoogleDocs(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: getBlockStyle(schema, el),\n            children: next(el.firstChild?.childNodes || []),\n          }\n        }\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el.classList.contains('apple-interchange-newline')\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs inside empty paragraphs\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          el?.parentNode?.textContent === ''\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n\n        // BRs on the root\n        if (\n          tagName(el) === 'br' &&\n          isGoogleDocs(el) &&\n          isElement(el) &&\n          isRootNode(el)\n        ) {\n          return {\n            ...DEFAULT_SPAN,\n            text: '',\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {tagName} from '../helpers'\n\nexport const whitespaceTextNodeRule: DeserializerRule = {\n  deserialize(node) {\n    return node.nodeName === '#text' && isWhitespaceTextNode(node)\n      ? {\n          ...DEFAULT_SPAN,\n          marks: [],\n          text: (node.textContent ?? '').replace(/\\s\\s+/g, ' '),\n        }\n      : undefined\n  },\n}\n\nfunction isWhitespaceTextNode(node: Node) {\n  const isValidWhiteSpace =\n    node.nodeType === 3 &&\n    (node.textContent || '').replace(/[\\r\\n]/g, ' ').replace(/\\s\\s+/g, ' ') ===\n      ' ' &&\n    node.nextSibling &&\n    node.nextSibling.nodeType !== 3 &&\n    node.previousSibling &&\n    node.previousSibling.nodeType !== 3\n\n  return (\n    (isValidWhiteSpace || node.textContent !== ' ') &&\n    tagName(node.parentNode) !== 'body'\n  )\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  DEFAULT_BLOCK,\n  DEFAULT_SPAN,\n  HTML_BLOCK_TAGS,\n  HTML_DECORATOR_TAGS,\n  HTML_HEADER_TAGS,\n  HTML_LIST_CONTAINER_TAGS,\n  HTML_LIST_ITEM_TAGS,\n  HTML_SPAN_TAGS,\n  type PartialBlock,\n} from '../../constants'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport {keyGenerator} from '../../util/randomKey'\nimport {isElement, tagName} from '../helpers'\nimport {whitespaceTextNodeRule} from './whitespace-text-node'\n\nexport function resolveListItem(\n  schema: Schema,\n  listNodeTagName: string,\n): string | undefined {\n  if (\n    listNodeTagName === 'ul' &&\n    schema.lists.some((list) => list.name === 'bullet')\n  ) {\n    return 'bullet'\n  }\n  if (\n    listNodeTagName === 'ol' &&\n    schema.lists.some((list) => list.name === 'number')\n  ) {\n    return 'number'\n  }\n  return undefined\n}\n\nexport default function createHTMLRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    whitespaceTextNodeRule,\n    {\n      // Pre element\n      deserialize(el) {\n        if (tagName(el) !== 'pre') {\n          return undefined\n        }\n\n        const isCodeEnabled = schema.styles.some(\n          (style) => style.name === 'code',\n        )\n\n        return {\n          _type: 'block',\n          style: 'normal',\n          markDefs: [],\n          children: [\n            {\n              ...DEFAULT_SPAN,\n              marks: isCodeEnabled ? ['code'] : [],\n              text: el.textContent || '',\n            },\n          ],\n        }\n      },\n    }, // Blockquote element\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'blockquote') {\n          return undefined\n        }\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        delete blocks.blockquote\n        const nonBlockquoteBlocks = Object.keys(blocks)\n\n        const children: HTMLElement[] = []\n\n        el.childNodes.forEach((node, index) => {\n          if (!el.ownerDocument) {\n            return\n          }\n\n          if (\n            node.nodeType === 1 &&\n            nonBlockquoteBlocks.includes(\n              (node as Element).localName.toLowerCase(),\n            )\n          ) {\n            const span = el.ownerDocument.createElement('span')\n\n            const previousChild = children[children.length - 1]\n\n            if (\n              previousChild &&\n              previousChild.nodeType === 3 &&\n              previousChild.textContent?.trim()\n            ) {\n              // Only prepend line break if the previous node is a non-empty\n              // text node.\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            node.childNodes.forEach((cn) => {\n              span.appendChild(cn.cloneNode(true))\n            })\n\n            if (index !== el.childNodes.length) {\n              // Only append line break if this is not the last child\n              span.appendChild(el.ownerDocument.createTextNode('\\r'))\n            }\n\n            children.push(span)\n          } else {\n            children.push(node as HTMLElement)\n          }\n        })\n\n        return {\n          _type: 'block',\n          style: 'blockquote',\n          markDefs: [],\n          children: next(children),\n        }\n      },\n    }, // Block elements\n    {\n      deserialize(el, next) {\n        const blocks: Record<string, PartialBlock | undefined> = {\n          ...HTML_BLOCK_TAGS,\n          ...HTML_HEADER_TAGS,\n        }\n        const tag = tagName(el)\n        let block = tag ? blocks[tag] : undefined\n        if (!block) {\n          return undefined\n        }\n        // Don't add blocks into list items\n        if (el.parentNode && tagName(el.parentNode) === 'li') {\n          return next(el.childNodes)\n        }\n        const blockStyle = block.style\n        // If style is not supported, return a defaultBlockType\n        if (!schema.styles.some((style) => style.name === blockStyle)) {\n          block = DEFAULT_BLOCK\n        }\n        return {\n          ...block,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Ignore span tags\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_SPAN_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore div tags\n    {\n      deserialize(el, next) {\n        const div = tagName(el) === 'div'\n        if (!div) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Ignore list containers\n    {\n      deserialize(el, next) {\n        const tag = tagName(el)\n        if (!tag || !(tag in HTML_LIST_CONTAINER_TAGS)) {\n          return undefined\n        }\n        return next(el.childNodes)\n      },\n    }, // Deal with br's\n    {\n      deserialize(el) {\n        if (tagName(el) === 'br') {\n          return {\n            ...DEFAULT_SPAN,\n            text: '\\n',\n          }\n        }\n        return undefined\n      },\n    }, // Deal with list items\n    {\n      deserialize(el, next, block) {\n        const tag = tagName(el)\n        const listItem = tag ? HTML_LIST_ITEM_TAGS[tag] : undefined\n        const parentTag = tagName(el.parentNode) || ''\n        if (\n          !listItem ||\n          !el.parentNode ||\n          !HTML_LIST_CONTAINER_TAGS[parentTag]\n        ) {\n          return undefined\n        }\n        const enabledListItem = resolveListItem(schema, parentTag)\n        // If the list item style is not supported, return a new default block\n        if (!enabledListItem) {\n          return block({_type: 'block', children: next(el.childNodes)})\n        }\n        listItem.listItem = enabledListItem\n        return {\n          ...listItem,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Deal with decorators - this is a limited set of known html elements that we know how to deserialize\n    {\n      deserialize(el, next) {\n        const decorator = HTML_DECORATOR_TAGS[tagName(el) || '']\n        if (\n          !decorator ||\n          !schema.decorators.some(\n            (decoratorType) => decoratorType.name === decorator,\n          )\n        ) {\n          return undefined\n        }\n        return {\n          _type: '__decorator',\n          name: decorator,\n          children: next(el.childNodes),\n        }\n      },\n    }, // Special case for hyperlinks, add annotation (if allowed by schema),\n    // If not supported just write out the link text and href in plain text.\n    {\n      deserialize(el, next) {\n        if (tagName(el) !== 'a') {\n          return undefined\n        }\n        const linkEnabled = schema.annotations.some(\n          (annotation) => annotation.name === 'link',\n        )\n        const href = isElement(el) && el.getAttribute('href')\n        if (!href) {\n          return next(el.childNodes)\n        }\n        if (linkEnabled) {\n          return {\n            _type: '__annotation',\n            markDef: {\n              _key: options.keyGenerator\n                ? options.keyGenerator()\n                : keyGenerator(),\n              _type: 'link',\n              href: href,\n            },\n            children: next(el.childNodes),\n          }\n        }\n        return (\n          el.appendChild(el.ownerDocument.createTextNode(` (${href})`)) &&\n          next(el.childNodes)\n        )\n      },\n    },\n    {\n      deserialize(el, next) {\n        if (isElement(el) && (tagName(el) === 'td' || tagName(el) === 'th')) {\n          return {\n            ...DEFAULT_BLOCK,\n            children: next(el.childNodes),\n          }\n        }\n\n        return undefined\n      },\n    },\n    {\n      deserialize(el) {\n        if (isElement(el) && tagName(el) === 'img') {\n          const src = el.getAttribute('src') ?? undefined\n          const alt = el.getAttribute('alt') ?? undefined\n\n          const props = Object.fromEntries(\n            Array.from(el.attributes).map((attr) => [attr.name, attr.value]),\n          )\n\n          const ancestorOfLonelyChild =\n            el?.parentElement?.parentElement?.getAttribute('data-lonely-child')\n          const ancestorOfListItem = el.closest('li') !== null\n\n          if (ancestorOfLonelyChild && !ancestorOfListItem) {\n            const image = options.matchers?.image?.({\n              context: {\n                schema,\n                keyGenerator: options.keyGenerator ?? keyGenerator,\n              },\n              props: {\n                ...props,\n                ...(src ? {src} : {}),\n                ...(alt ? {alt} : {}),\n              },\n            })\n\n            if (image) {\n              return {\n                _type: '__block',\n                block: image,\n              }\n            }\n          }\n\n          const inlineImage = options.matchers?.inlineImage?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (inlineImage) {\n            return inlineImage\n          }\n\n          const image = options.matchers?.image?.({\n            context: {\n              schema,\n              keyGenerator: options.keyGenerator ?? keyGenerator,\n            },\n            props: {\n              ...props,\n              ...(src ? {src} : {}),\n              ...(alt ? {alt} : {}),\n            },\n          })\n\n          if (image) {\n            return {\n              _type: '__block',\n              block: image,\n            }\n          }\n        }\n\n        return undefined\n      },\n    },\n  ]\n}\n","import {DEFAULT_SPAN} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\n// font-style:italic seems like the most important rule for italic / emphasis in their html\nfunction isEmphasis(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /font-style:italic/.test(style || '')\n}\n\n// font-weight:700 or 600 seems like the most important rule for bold in their html\nfunction isStrong(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return (\n    /font-weight:700/.test(style || '') || /font-weight:600/.test(style || '')\n  )\n}\n\n// text-decoration seems like the most important rule for underline in their html\nfunction isUnderline(el: Node): boolean {\n  const style = isElement(el) && el.getAttribute('style')\n  return /text-decoration:underline/.test(style || '')\n}\n\n// Check for attribute given by the Notion preprocessor\nfunction isNotion(el: Node): boolean {\n  return isElement(el) && Boolean(el.getAttribute('data-is-notion'))\n}\n\nexport default function createNotionRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el) {\n        // Notion normally exports semantic HTML. However, if you copy a single block, the formatting will be inline styles\n        // This handles a limited set of styles\n        if (isElement(el) && tagName(el) === 'span' && isNotion(el)) {\n          const span = {\n            ...DEFAULT_SPAN,\n            marks: [] as string[],\n            text: el.textContent,\n          }\n          if (isStrong(el)) {\n            span.marks.push('strong')\n          }\n          if (isUnderline(el)) {\n            span.marks.push('underline')\n          }\n          if (isEmphasis(el)) {\n            span.marks.push('em')\n          }\n          return span\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import {BLOCK_DEFAULT_STYLE, DEFAULT_BLOCK} from '../../constants'\nimport type {DeserializerRule} from '../../types'\nimport {isElement, tagName} from '../helpers'\n\nfunction getListItemStyle(el: Node): string | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  if (!style.match(/lfo\\d+/)) {\n    return undefined\n  }\n\n  return style.match('lfo1') ? 'bullet' : 'number'\n}\n\nfunction getListItemLevel(el: Node): number | undefined {\n  const style = isElement(el) && el.getAttribute('style')\n  if (!style) {\n    return undefined\n  }\n\n  const levelMatch = style.match(/level\\d+/)\n  if (!levelMatch) {\n    return undefined\n  }\n\n  const [level] = levelMatch[0].match(/\\d/) || []\n  const levelNum = level ? Number.parseInt(level, 10) : 1\n  return levelNum || 1\n}\n\nfunction isWordListElement(el: Node): boolean {\n  return isElement(el) && el.className\n    ? el.className === 'MsoListParagraphCxSpFirst' ||\n        el.className === 'MsoListParagraphCxSpMiddle' ||\n        el.className === 'MsoListParagraphCxSpLast'\n    : false\n}\n\nexport default function createWordRules(): DeserializerRule[] {\n  return [\n    {\n      deserialize(el, next) {\n        if (tagName(el) === 'p' && isWordListElement(el)) {\n          return {\n            ...DEFAULT_BLOCK,\n            listItem: getListItemStyle(el),\n            level: getListItemLevel(el),\n            style: BLOCK_DEFAULT_STYLE,\n            children: next(el.childNodes),\n          }\n        }\n        return undefined\n      },\n    },\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport type {SchemaMatchers} from '../../schema-matchers'\nimport type {DeserializerRule} from '../../types'\nimport createGDocsRules from './gdocs'\nimport createHTMLRules from './html'\nimport createNotionRules from './notion'\nimport createWordRules from './word'\n\nexport function createRules(\n  schema: Schema,\n  options: {keyGenerator?: () => string; matchers?: SchemaMatchers},\n): DeserializerRule[] {\n  return [\n    ...createWordRules(),\n    ...createNotionRules(),\n    ...createGDocsRules(schema),\n    ...createHTMLRules(schema, options),\n  ]\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isTextBlock,\n  type PortableTextBlock,\n  type PortableTextObject,\n} from '@portabletext/schema'\nimport {flatten} from 'lodash'\nimport type {\n  ArbitraryTypedObject,\n  DeserializerRule,\n  HtmlDeserializerOptions,\n  PlaceholderAnnotation,\n  PlaceholderDecorator,\n  TypedObject,\n} from '../types'\nimport {keyGenerator} from '../util/randomKey'\nimport {resolveJsType} from '../util/resolveJsType'\nimport {flattenNestedBlocks} from './flatten-nested-blocks'\nimport {\n  defaultParseHtml,\n  ensureRootIsBlocks,\n  isMinimalBlock,\n  isMinimalSpan,\n  isNodeList,\n  isPlaceholderAnnotation,\n  isPlaceholderDecorator,\n  preprocess,\n  tagName,\n  trimWhitespace,\n} from './helpers'\nimport {createRules} from './rules'\n\n/**\n * HTML Deserializer\n *\n */\nexport default class HtmlDeserializer {\n  keyGenerator: () => string\n  schema: Schema\n  rules: DeserializerRule[]\n  parseHtml: (html: string) => HTMLElement\n  _markDefs: PortableTextObject[] = []\n\n  /**\n   * Create a new serializer respecting a Sanity block content type's schema\n   *\n   * @param blockContentType - Schema type for array containing _at least_ a block child type\n   * @param options - Options for the deserialization process\n   */\n  constructor(schema: Schema, options: HtmlDeserializerOptions = {}) {\n    const {rules = [], unstable_whitespaceOnPasteMode = 'preserve'} = options\n    const standardRules = createRules(schema, {\n      keyGenerator: options.keyGenerator,\n      matchers: options.matchers,\n    })\n    this.schema = schema\n    this.keyGenerator = options.keyGenerator ?? keyGenerator\n    this.rules = [...rules, ...standardRules]\n    const parseHtml = options.parseHtml || defaultParseHtml()\n    this.parseHtml = (html) => {\n      const doc = preprocess(html, parseHtml, {unstable_whitespaceOnPasteMode})\n      return doc.body\n    }\n  }\n\n  /**\n   * Deserialize HTML.\n   *\n   * @param html - The HTML to deserialize, as a string\n   * @returns Array of blocks - either portable text blocks or other allowed blocks\n   */\n  deserialize = (html: string): TypedObject[] => {\n    this._markDefs = []\n    const {parseHtml} = this\n    const fragment = parseHtml(html)\n    const children = Array.from(fragment.childNodes) as HTMLElement[]\n    // Ensure that there are no blocks within blocks, and trim whitespace\n    const blocks = trimWhitespace(\n      this.schema,\n      flattenNestedBlocks(\n        {schema: this.schema},\n        ensureRootIsBlocks(\n          this.schema,\n          this.deserializeElements(children) as Array<ArbitraryTypedObject>,\n        ),\n      ),\n    )\n\n    if (this._markDefs.length > 0) {\n      blocks\n        .filter((block) => isTextBlock({schema: this.schema}, block))\n        .forEach((block) => {\n          block.markDefs = block.markDefs || []\n          block.markDefs = block.markDefs.concat(\n            this._markDefs.filter((def) => {\n              return flatten(\n                block.children.map((child) => child.marks || []),\n              ).includes(def._key)\n            }),\n          )\n        })\n    }\n\n    return blocks.map((block) => {\n      if (block._type === 'block') {\n        block._type = this.schema.block.name\n      }\n      return block\n    })\n  }\n\n  /**\n   * Deserialize an array of DOM elements.\n   *\n   * @param elements - Array of DOM elements to deserialize\n   * @returns\n   */\n  deserializeElements = (elements: Node[] = []): TypedObject[] => {\n    let nodes: TypedObject[] = []\n    elements.forEach((element) => {\n      nodes = nodes.concat(this.deserializeElement(element))\n    })\n    return nodes\n  }\n\n  /**\n   * Deserialize a DOM element\n   *\n   * @param element - Deserialize a DOM element\n   * @returns\n   */\n  deserializeElement = (element: Node): TypedObject | TypedObject[] => {\n    const next = (\n      elements: Node | Node[] | NodeList,\n    ): TypedObject | TypedObject[] | undefined => {\n      if (isNodeList(elements)) {\n        return this.deserializeElements(Array.from(elements))\n      }\n\n      if (Array.isArray(elements)) {\n        return this.deserializeElements(elements)\n      }\n\n      if (!elements) {\n        return undefined\n      }\n\n      return this.deserializeElement(elements)\n    }\n\n    const block = (props: ArbitraryTypedObject) => {\n      return {\n        _type: '__block',\n        block: props,\n      }\n    }\n\n    let node: TypedObject | Array<TypedObject> | undefined\n    for (let i = 0; i < this.rules.length; i++) {\n      const rule = this.rules[i]\n      if (!rule.deserialize) {\n        continue\n      }\n\n      const ret = rule.deserialize(element, next, block)\n      const type = resolveJsType(ret)\n\n      if (\n        type !== 'array' &&\n        type !== 'object' &&\n        type !== 'null' &&\n        type !== 'undefined'\n      ) {\n        throw new Error(\n          `A rule returned an invalid deserialized representation: \"${node}\".`,\n        )\n      }\n\n      if (ret === undefined) {\n        continue\n      } else if (ret === null) {\n        throw new Error('Deserializer rule returned `null`')\n      } else if (Array.isArray(ret)) {\n        node = ret\n      } else if (isPlaceholderDecorator(ret)) {\n        node = this.deserializeDecorator(ret)\n      } else if (isPlaceholderAnnotation(ret)) {\n        node = this.deserializeAnnotation(ret)\n      } else {\n        node = ret\n      }\n\n      // Set list level on list item\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        'listItem' in ret\n      ) {\n        let parent = element.parentNode?.parentNode\n        while (parent && tagName(parent) === 'li') {\n          parent = parent.parentNode?.parentNode\n          ret.level = ret.level ? ret.level + 1 : 1\n        }\n      }\n\n      // Set newlines on spans orginating from a block element within a blockquote\n      if (\n        ret &&\n        !Array.isArray(ret) &&\n        isMinimalBlock(ret) &&\n        ret.style === 'blockquote'\n      ) {\n        ret.children.forEach((child, index) => {\n          if (isMinimalSpan(child) && child.text === '\\r') {\n            child.text = '\\n'\n            if (index === 0 || index === ret.children.length - 1) {\n              ret.children.splice(index, 1)\n            }\n          }\n        })\n      }\n      break\n    }\n\n    return node || next(element.childNodes) || []\n  }\n\n  /**\n   * Deserialize a `__decorator` type\n   * (an internal made up type to process decorators exclusively)\n   *\n   * @param decorator -\n   * @returns array of ...\n   */\n  deserializeDecorator = (decorator: PlaceholderDecorator): TypedObject[] => {\n    const {name} = decorator\n    const applyDecorator = (node: TypedObject) => {\n      if (isPlaceholderDecorator(node)) {\n        return this.deserializeDecorator(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(name)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyDecorator)\n      }\n      return node\n    }\n    return decorator.children.reduce((children, node) => {\n      const ret = applyDecorator(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n\n  /**\n   * Deserialize a `__annotation` object.\n   * (an internal made up type to process annotations exclusively)\n   *\n   * @param annotation -\n   * @returns Array of...\n   */\n  deserializeAnnotation = (\n    annotation: PlaceholderAnnotation,\n  ): TypedObject[] => {\n    const {markDef} = annotation\n    this._markDefs.push(markDef)\n    const applyAnnotation = (node: TypedObject) => {\n      if (isPlaceholderAnnotation(node)) {\n        return this.deserializeAnnotation(node)\n      } else if (isMinimalSpan(node)) {\n        node.marks = node.marks || []\n        if (node.text.trim()) {\n          // Only apply marks if this is an actual text\n          node.marks.unshift(markDef._key)\n        }\n      } else if (\n        'children' in node &&\n        Array.isArray((node as PortableTextBlock).children)\n      ) {\n        const block = node as any\n        block.children = block.children.map(applyAnnotation)\n      }\n      return node\n    }\n    return annotation.children.reduce((children, node) => {\n      const ret = applyAnnotation(node)\n      if (Array.isArray(ret)) {\n        return children.concat(ret)\n      }\n      children.push(ret)\n      return children\n    }, [] as TypedObject[])\n  }\n}\n","import type {Schema} from '@portabletext/schema'\nimport {\n  isSpan,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@portabletext/schema'\nimport {isEqual} from 'lodash'\nimport type {TypedObject} from '../types'\nimport {keyGenerator} from './randomKey'\n\n/**\n * Block normalization options\n *\n * @public\n */\nexport interface BlockNormalizationOptions {\n  /**\n   * Decorator names that are allowed within portable text blocks, eg `em`, `strong`\n   */\n  allowedDecorators?: string[]\n\n  /**\n   * Name of the portable text block type, if not `block`\n   */\n  blockTypeName?: string\n\n  /**\n   * Custom key generator function\n   */\n  keyGenerator?: () => string\n}\n\n/**\n * Normalizes a block by ensuring it has a `_key` property. If the block is a\n * portable text block, additional normalization is applied:\n *\n * - Ensures it has `children` and `markDefs` properties\n * - Ensures it has at least one child (adds an empty span if empty)\n * - Joins sibling spans that has the same marks\n * - Removes decorators that are not allowed according to the schema\n * - Removes marks that have no annotation definition\n *\n * @param node - The block to normalize\n * @param options - Options for normalization process. See {@link BlockNormalizationOptions}\n * @returns Normalized block\n * @public\n */\nexport function normalizeBlock(\n  node: TypedObject,\n  options: BlockNormalizationOptions = {},\n): Omit<\n  TypedObject | PortableTextTextBlock<TypedObject | PortableTextSpan>,\n  '_key'\n> & {\n  _key: string\n} {\n  const schema: Schema = {\n    block: {\n      name: options.blockTypeName || 'block',\n    },\n    span: {\n      name: 'span',\n    },\n    styles: [],\n    lists: [],\n    decorators: [],\n    annotations: [],\n    blockObjects: [],\n    inlineObjects: [],\n  }\n\n  if (node._type !== (options.blockTypeName || 'block')) {\n    return '_key' in node\n      ? (node as TypedObject & {_key: string})\n      : {\n          ...node,\n          _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        }\n  }\n\n  const block: Omit<\n    PortableTextTextBlock<TypedObject | PortableTextSpan>,\n    'style'\n  > = {\n    _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n    children: [],\n    markDefs: [],\n    ...node,\n  }\n\n  const lastChild = block.children[block.children.length - 1]\n\n  if (!lastChild) {\n    // A block must at least have an empty span type child\n    block.children = [\n      {\n        _type: 'span',\n        _key: options.keyGenerator ? options.keyGenerator() : keyGenerator(),\n        text: '',\n        marks: [],\n      },\n    ]\n    return block\n  }\n\n  const usedMarkDefs: string[] = []\n  const allowedDecorators =\n    options.allowedDecorators && Array.isArray(options.allowedDecorators)\n      ? options.allowedDecorators\n      : false\n\n  block.children = block.children\n    .reduce(\n      (acc, child) => {\n        const previousChild = acc[acc.length - 1]\n        if (\n          previousChild &&\n          isSpan({schema}, child) &&\n          isSpan({schema}, previousChild) &&\n          isEqual(previousChild.marks, child.marks)\n        ) {\n          if (\n            lastChild &&\n            lastChild === child &&\n            child.text === '' &&\n            block.children.length > 1\n          ) {\n            return acc\n          }\n\n          previousChild.text += child.text\n          return acc\n        }\n        acc.push(child)\n        return acc\n      },\n      [] as (TypedObject | PortableTextSpan)[],\n    )\n    .map((child) => {\n      if (!child) {\n        throw new Error('missing child')\n      }\n\n      child._key = options.keyGenerator\n        ? options.keyGenerator()\n        : keyGenerator()\n\n      if (isSpan({schema}, child)) {\n        if (!child.marks) {\n          child.marks = []\n        } else if (allowedDecorators) {\n          child.marks = child.marks.filter((mark) => {\n            const isAllowed = allowedDecorators.includes(mark)\n            const isUsed = block.markDefs?.some((def) => def._key === mark)\n            return isAllowed || isUsed\n          })\n        }\n\n        usedMarkDefs.push(...child.marks)\n      }\n\n      return child\n    })\n\n  // Remove leftover (unused) markDefs\n  block.markDefs = (block.markDefs || []).filter((markDef) =>\n    usedMarkDefs.includes(markDef._key),\n  )\n\n  return block\n}\n","import {sanitySchemaToPortableTextSchema} from '@portabletext/sanity-bridge'\nimport type {Schema} from '@portabletext/schema'\nimport type {ArraySchemaType} from '@sanity/types'\nimport HtmlDeserializer from './HtmlDeserializer'\nimport type {HtmlDeserializerOptions, TypedObject} from './types'\nimport {normalizeBlock} from './util/normalizeBlock'\n\n/**\n * Convert HTML to blocks respecting the block content type's schema\n *\n * @param html - The HTML to convert to blocks\n * @param schemaType - A compiled version of the schema type for the block content\n * @param options - Options for deserializing HTML to blocks\n * @returns Array of blocks\n * @public\n */\nexport function htmlToBlocks(\n  html: string,\n  schemaType: ArraySchemaType | Schema,\n  options: HtmlDeserializerOptions = {},\n) {\n  const schema = isSanitySchema(schemaType)\n    ? sanitySchemaToPortableTextSchema(schemaType)\n    : schemaType\n\n  const deserializer = new HtmlDeserializer(schema, options)\n  return deserializer\n    .deserialize(html)\n    .map((block) => normalizeBlock(block, {keyGenerator: options.keyGenerator}))\n}\n\nexport type {ImageSchemaMatcher, SchemaMatchers} from './schema-matchers'\nexport type {ArbitraryTypedObject, DeserializerRule, HtmlParser} from './types'\nexport type {\n  PortableTextBlock,\n  PortableTextObject,\n  PortableTextSpan,\n  PortableTextTextBlock,\n} from '@portabletext/schema'\nexport type {BlockNormalizationOptions} from './util/normalizeBlock'\nexport {randomKey} from './util/randomKey'\nexport {normalizeBlock}\nexport type {HtmlDeserializerOptions, TypedObject}\n\nfunction isSanitySchema(\n  schema: ArraySchemaType | Schema,\n): schema is ArraySchemaType {\n  return schema.hasOwnProperty('jsonType')\n}\n"],"names":["isEmphasis","isStrong","isUnderline","getListItemStyle","getListItemLevel","blocks","image"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9],"debugId":null}},
    {"offset": {"line": 2038, "column": 0}, "map": {"version":3,"file":"pt-to-html.mjs","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/escape.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/components/list.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/components/marks.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/warnings.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/components/unknown.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/components/defaults.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/components/merge.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/to-html/src/to-html.ts"],"sourcesContent":["const allowedProtocols = ['http', 'https', 'mailto', 'tel']\nconst charMap: Record<string, string> = {\n  '&': 'amp',\n  '<': 'lt',\n  '>': 'gt',\n  '\"': 'quot',\n  \"'\": '#x27',\n}\n\nexport function escapeHTML(str: string): string {\n  return replaceMultipleSpaces(str.replace(/[&<>\"']/g, (s) => `&${charMap[s]};`))\n}\n\nexport function replaceMultipleSpaces(str: string): string {\n  return str.replace(/ {2,}/g, (match: string) => `${'&nbsp;'.repeat(match.length - 1)} `)\n}\n\nexport function uriLooksSafe(uri: string): boolean {\n  const url = (uri || '').trim()\n  const first = url.charAt(0)\n\n  // Allow hash-links, absolute paths and \"same-protocol\" (//foo.bar) URLs\n  if (first === '#' || first === '/') {\n    return true\n  }\n\n  // If the URL does not contain a `:`, allow it\n  const colonIndex = url.indexOf(':')\n  if (colonIndex === -1) {\n    return true\n  }\n\n  // If the protocol is in the allowed list, treat it as OK\n  const proto = url.slice(0, colonIndex).toLowerCase()\n  if (allowedProtocols.indexOf(proto) !== -1) {\n    return true\n  }\n\n  // If the URL is `site/search?query=author:espen`, allow it\n  const queryIndex = url.indexOf('?')\n  if (queryIndex !== -1 && colonIndex > queryIndex) {\n    return true\n  }\n\n  // If the URL is `site/search#my:encoded:data`, allow it\n  const hashIndex = url.indexOf('#')\n  if (hashIndex !== -1 && colonIndex > hashIndex) {\n    return true\n  }\n\n  return false\n}\n","import type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => `<ol>${children}</ol>`,\n  bullet: ({children}) => `<ul>${children}</ul>`,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => `<li>${children}</li>`\n","import type {TypedObject} from '@portabletext/types'\n\nimport {escapeHTML, uriLooksSafe} from '../escape'\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => {\n  const href = value?.href || ''\n  const looksSafe = uriLooksSafe(href)\n  return looksSafe ? `<a href=\"${escapeHTML(href)}\">${children}</a>` : children\n}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  'em': ({children}) => `<em>${children}</em>`,\n  'strong': ({children}) => `<strong>${children}</strong>`,\n  'code': ({children}) => `<code>${children}</code>`,\n  'underline': ({children}) => `<span style=\"text-decoration:underline\">${children}</span>`,\n  'strike-through': ({children}) => `<del>${children}</del>`,\n  link,\n}\n","const getTemplate = (type: string, prop: string): string =>\n  `Unknown ${type}, specify a component for it in the \\`components.${prop}\\` option`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  console.warn(message)\n}\n","import type {PortableTextHtmlComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nexport const DefaultUnknownType: PortableTextHtmlComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline\n    ? `<span style=\"display:none\">${warning}</span>`\n    : `<div style=\"display:none\">${warning}</div>`\n}\n\nexport const DefaultUnknownMark: PortableTextHtmlComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return `<span class=\"unknown__pt__mark__${markType}\">${children}</span>`\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextHtmlComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return `<p>${children}</p>`\n}\n\nexport const DefaultUnknownList: PortableTextHtmlComponents['unknownList'] = ({children}) => {\n  return `<ul>${children}</ul>`\n}\n\nexport const DefaultUnknownListItem: PortableTextHtmlComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return `<li>${children}</li>`\n}\n","import type {PortableTextBlockStyle} from '@portabletext/types'\n\nimport {escapeHTML} from '../escape'\nimport type {PortableTextBlockComponent, PortableTextHtmlComponents} from '../types'\nimport {DefaultListItem, defaultLists} from './list'\nimport {defaultMarks} from './marks'\nimport {\n  DefaultUnknownBlockStyle,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownMark,\n  DefaultUnknownType,\n} from './unknown'\n\nexport const DefaultHardBreak = (): string => '<br/>'\n\nexport const defaultPortableTextBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => `<p>${children}</p>`,\n  blockquote: ({children}) => `<blockquote>${children}</blockquote>`,\n  h1: ({children}) => `<h1>${children}</h1>`,\n  h2: ({children}) => `<h2>${children}</h2>`,\n  h3: ({children}) => `<h3>${children}</h3>`,\n  h4: ({children}) => `<h4>${children}</h4>`,\n  h5: ({children}) => `<h5>${children}</h5>`,\n  h6: ({children}) => `<h6>${children}</h6>`,\n}\n\nexport const defaultComponents: PortableTextHtmlComponents = {\n  types: {},\n\n  block: defaultPortableTextBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n  escapeHTML: escapeHTML,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n","import type {PortableTextComponents, PortableTextHtmlComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n): PortableTextHtmlComponents {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  const {block, list, listItem, marks, types, ...rest} = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextHtmlComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextHtmlComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextHtmlComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextHtmlComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextHtmlComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextHtmlComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types',\n): PortableTextHtmlComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextHtmlComponents[typeof key]\n  }\n\n  return parentVal\n}\n","import {\n  buildMarksTree,\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  nestLists,\n  spanToPlainText,\n  type ToolkitNestedPortableTextSpan,\n  type ToolkitTextNode,\n} from '@portabletext/toolkit'\nimport type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\n\nimport {defaultComponents} from './components/defaults'\nimport {mergeComponents} from './components/merge'\nimport type {\n  HtmlPortableTextList,\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextHtmlComponents,\n  PortableTextOptions,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function toHTML<B extends TypedObject = PortableTextBlock | ArbitraryTypedObject>(\n  value: B | B[],\n  options: PortableTextOptions = {},\n): string {\n  const {\n    components: componentOverrides,\n    onMissingComponent: missingComponentHandler = printWarning,\n  } = options\n\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(value) ? value : [value]\n  const nested = nestLists(blocks, 'html')\n  const components = componentOverrides\n    ? mergeComponents(defaultComponents, componentOverrides)\n    : defaultComponents\n\n  const renderNode = getNodeRenderer(components, handleMissingComponent)\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode}),\n  )\n\n  return rendered.join('')\n}\n\nconst getNodeRenderer = (\n  components: PortableTextHtmlComponents,\n  handleMissingComponent: MissingComponentHandler,\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): string {\n    const {node, index, isInline} = options\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node)\n    }\n\n    return renderCustomBlock(node, index, isInline)\n  }\n\n  function renderListItem(\n    node: PortableTextListItemBlock<PortableTextMarkDefinition, PortableTextSpan>,\n    index: number,\n  ): string {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const itemHandler = handler || components.unknownListItem\n\n    if (itemHandler === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block component says to use\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const {listItem, ...blockNode} = node\n      children = renderNode({node: blockNode, index, isInline: false, renderNode})\n    }\n\n    return itemHandler({value: node, index, isInline: false, renderNode, children})\n  }\n\n  function renderList(node: HtmlPortableTextList, index: number): string {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: childIndex,\n        isInline: false,\n        renderNode,\n      }),\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const list = handler || components.unknownList\n\n    if (list === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {nodeType: 'listStyle', type: style})\n    }\n\n    return list({value: node, index, isInline: false, renderNode, children: children.join('')})\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan): string {\n    const {markDef, markType, markKey} = node\n    const span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode}),\n    )\n\n    if (span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {nodeType: 'mark', type: markType})\n    }\n\n    return span({\n      text: spanToPlainText(node),\n      value: markDef,\n      markType,\n      markKey,\n      renderNode,\n      children: children.join(''),\n    })\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, isInline: boolean): string {\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const block = handler || components.unknownBlockStyle\n\n    if (block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return block({...props, value: props.node, renderNode})\n  }\n\n  function renderText(node: ToolkitTextNode): string {\n    if (node.text === '\\n') {\n      const hardBreak = components.hardBreak\n      return hardBreak ? hardBreak() : '\\n'\n    }\n\n    return components.escapeHTML(node.text)\n  }\n\n  function renderCustomBlock(value: TypedObject, index: number, isInline: boolean): string {\n    const node = components.types[value._type]\n\n    if (!node) {\n      handleMissingComponent(unknownTypeWarning(value._type), {\n        nodeType: 'block',\n        type: value._type,\n      })\n    }\n\n    const component = node || components.unknownType\n    return component({\n      value,\n      isInline,\n      index,\n      renderNode,\n    })\n  }\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode}),\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children: children.join(''),\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7],"debugId":null}},
    {"offset": {"line": 2291, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/arrayInsert.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/array.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/number.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/object.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/primitive.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/string.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/applyPatch.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/patches/src/patches.ts"],"sourcesContent":["export const BEFORE = 'before'\nexport const AFTER = 'after'\n\nexport default function insert(\n  array: any[],\n  position: string,\n  index: number,\n  ...args: any[]\n) {\n  if (position !== BEFORE && position !== AFTER) {\n    throw new Error(\n      `Invalid position \"${position}\", must be either ${BEFORE} or ${AFTER}`,\n    )\n  }\n\n  const items = flatten(...args)\n\n  if (array.length === 0) {\n    return items\n  }\n\n  const len = array.length\n  const idx = Math.abs((len + index) % len) % len\n\n  const normalizedIdx = position === 'after' ? idx + 1 : idx\n\n  const copy = array.slice()\n  copy.splice(normalizedIdx, 0, ...flatten(items))\n  return copy\n}\n\nfunction flatten(...values: any[]) {\n  return values.reduce((prev, item) => prev.concat(item), [])\n}\n","import {findIndex} from 'lodash'\nimport applyPatch from './applyPatch'\nimport insert from './arrayInsert'\nimport type {JSONValue, Patch, PathSegment} from './types'\n\nfunction findTargetIndex(array: any[], pathSegment: PathSegment | undefined) {\n  if (typeof pathSegment === 'number') {\n    return pathSegment\n  }\n  const index = findIndex(array, pathSegment)\n  return index === -1 ? false : index\n}\n\nexport function applyPatchToArray(\n  value: Array<JSONValue>,\n  patch: Patch,\n): Array<JSONValue> | undefined {\n  const nextValue = value.slice() // make a copy for internal mutation\n\n  if (patch.path.length === 0) {\n    // its directed to me\n    if (patch.type === 'setIfMissing') {\n      if (!Array.isArray(patch.value)) {\n        throw new Error('Cannot set value of an array to a non-array')\n      }\n\n      return value === undefined ? patch.value : value\n    }\n\n    if (patch.type === 'set') {\n      if (!Array.isArray(patch.value)) {\n        throw new Error('Cannot set value of an array to a non-array')\n      }\n\n      return patch.value\n    }\n\n    if (patch.type === 'unset') {\n      return undefined\n    }\n\n    throw new Error(`Invalid array operation: ${patch.type}`)\n  }\n\n  const [head, ...tail] = patch.path\n\n  const index = findTargetIndex(value, head)\n\n  // If the given selector could not be found, return as-is\n  if (index === false) {\n    return nextValue\n  }\n\n  if (tail.length === 0) {\n    if (patch.type === 'insert') {\n      const {position, items} = patch\n      return insert(value, position, index, items)\n    } else if (patch.type === 'unset') {\n      if (typeof index !== 'number') {\n        throw new Error(\n          `Expected array index to be a number, instead got \"${index}\"`,\n        )\n      }\n      nextValue.splice(index, 1)\n      return nextValue\n    }\n  }\n\n  // The patch is not directed to me\n  nextValue[index] = applyPatch(nextValue[index], {\n    ...patch,\n    path: tail,\n  }) as JSONValue\n\n  return nextValue\n}\n","import type {Patch} from './types'\n\nexport function applyPatchToNumber(value: number, patch: Patch) {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path\n        .map((path: any) => JSON.stringify(path))\n        .join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : value\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  if (patch.type === 'inc') {\n    if (typeof patch.value !== 'number') {\n      throw new Error('Cannot increment with a non-number')\n    }\n\n    return value + patch.value\n  }\n\n  if (patch.type === 'dec') {\n    if (typeof patch.value !== 'number') {\n      throw new Error('Cannot decrement with a non-number')\n    }\n\n    return value - patch.value\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for number. This is most likely a bug.`,\n  )\n}\n","import {clone, omit} from 'lodash'\nimport applyPatch from './applyPatch'\nimport type {JSONValue, Patch} from './types'\n\nexport function applyPatchToObject(\n  value: {[key: string]: JSONValue},\n  patch: Patch,\n): {[key: string]: JSONValue} | undefined {\n  const nextValue = clone(value)\n\n  if (patch.path.length === 0) {\n    // its directed to me\n    if (patch.type === 'set') {\n      if (\n        typeof patch.value === 'object' &&\n        patch.value !== null &&\n        !Array.isArray(patch.value)\n      ) {\n        return patch.value\n      }\n\n      throw new Error('Cannot set value of an object to a non-object')\n    }\n\n    if (patch.type === 'unset') {\n      return undefined\n    }\n\n    throw new Error(`Invalid object operation: ${patch.type}`)\n  }\n\n  // The patch is not directed to me\n  const [head, ...tail] = patch.path\n\n  if (typeof head !== 'string') {\n    throw new Error(`Expected field name to be a string, instead got: ${head}`)\n  }\n\n  if (tail.length === 0 && patch.type === 'unset') {\n    return omit(nextValue, head)\n  }\n\n  if (!(head in nextValue) && tail.length > 0) {\n    // The field does not exist on the object so we can just return the object\n    // as is\n    return nextValue\n  }\n\n  nextValue[head] = applyPatch(nextValue[head], {\n    ...patch,\n    path: tail,\n  }) as JSONValue\n\n  return nextValue\n}\n","import type {JSONValue, Patch} from './types'\n\nexport function applyPatchToUnknown(\n  value: unknown,\n  patch: Patch,\n): JSONValue | undefined {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on primitive values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path\n        .map((path: any) => JSON.stringify(path))\n        .join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : (value as JSONValue)\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for primitives. This is most likely a bug.`,\n  )\n}\n","import {applyPatches, parsePatch} from '@sanity/diff-match-patch'\nimport type {Patch} from './types'\n\nexport function applyPatchToString(value: string, patch: Patch) {\n  if (patch.path.length > 0) {\n    throw new Error(\n      `Cannot apply deep operations on string values. Received patch with type \"${\n        patch.type\n      }\" and path \"${patch.path.join('.')} that targeted the value \"${JSON.stringify(value)}\"`,\n    )\n  }\n\n  if (patch.type === 'diffMatchPatch') {\n    const [result] = applyPatches(parsePatch(patch.value), value, {\n      allowExceedingIndices: true,\n    })\n    return result\n  }\n\n  if (patch.type === 'setIfMissing') {\n    return value === undefined ? patch.value : value\n  }\n\n  if (patch.type === 'set') {\n    return patch.value\n  }\n\n  if (patch.type === 'unset') {\n    return undefined\n  }\n\n  throw new Error(\n    `Received patch of unsupported type: \"${JSON.stringify(\n      patch.type,\n    )}\" for string. This is most likely a bug.`,\n  )\n}\n","import {applyPatchToArray} from './array'\nimport {applyPatchToNumber} from './number'\nimport {applyPatchToObject} from './object'\nimport {applyPatchToUnknown} from './primitive'\nimport {applyPatchToString} from './string'\nimport type {JSONValue, Patch} from './types'\n\n/** @beta */\nexport function applyAll<TValue>(value: TValue, patches: Array<Patch>): TValue {\n  return patches.reduce(applyPatch, value) as TValue\n}\n\nexport default function applyPatch(value: unknown, patch: Patch) {\n  if (Array.isArray(value)) {\n    return applyPatchToArray(value, patch)\n  }\n\n  if (typeof value === 'string') {\n    return applyPatchToString(value, patch)\n  }\n\n  if (isObject(value)) {\n    return applyPatchToObject(value, patch)\n  }\n\n  if (typeof value === 'number') {\n    return applyPatchToNumber(value, patch)\n  }\n\n  return applyPatchToUnknown(value, patch)\n}\n\nfunction isObject(value: unknown): value is {[key: string]: JSONValue} {\n  return typeof value === 'object' && value !== null && !Array.isArray(value)\n}\n","import {makePatches, stringifyPatches} from '@sanity/diff-match-patch'\nimport type {\n  DiffMatchPatch,\n  InsertPatch,\n  InsertPosition,\n  Path,\n  PathSegment,\n  SetIfMissingPatch,\n  SetPatch,\n  UnsetPatch,\n} from './types'\n\n/** @public */\nexport function setIfMissing(value: any, path: Path = []): SetIfMissingPatch {\n  return {\n    type: 'setIfMissing',\n    path,\n    value,\n  }\n}\n\n/** @public */\nexport function diffMatchPatch(\n  currentValue: string,\n  nextValue: string,\n  path: Path = [],\n): DiffMatchPatch {\n  const patches = makePatches(currentValue, nextValue)\n  const patch = stringifyPatches(patches)\n  return {type: 'diffMatchPatch', path, value: patch}\n}\n\n/** @public */\nexport function insert(\n  items: any[],\n  position: InsertPosition,\n  path: Path = [],\n): InsertPatch {\n  return {\n    type: 'insert',\n    path,\n    position,\n    items,\n  }\n}\n\n/** @public */\nexport function set(value: any, path: Path = []): SetPatch {\n  return {type: 'set', path, value}\n}\n\n/** @public */\nexport function unset(path: Path = []): UnsetPatch {\n  return {type: 'unset', path}\n}\n\n/** @internal */\nexport function prefixPath<T extends {path: Path}>(\n  patch: T,\n  segment: PathSegment,\n): T {\n  return {\n    ...patch,\n    path: [segment, ...patch.path],\n  }\n}\n"],"names":["insert"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7],"debugId":null}},
    {"offset": {"line": 2467, "column": 0}, "map": {"version":3,"file":"index.js","sources":["file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/keyboard-shortcuts/src/is-apple.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/keyboard-shortcuts/src/is-keyboard-shortcut.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/keyboard-shortcuts/src/keyboard-shortcuts.ts","file:///Users/isseemii/app/letterseed/node_modules/%40portabletext/keyboard-shortcuts/src/common-shortcuts.ts"],"sourcesContent":["export const IS_APPLE =\n  typeof window !== 'undefined' &&\n  /Mac|iPod|iPhone|iPad/.test(window.navigator.userAgent)\n","import type {KeyboardEventDefinition} from './keyboard-event-definition'\n\n/**\n * Checks if a keyboard event matches a keyboard shortcut definition.\n */\nexport function isKeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  >,\n>(definition: KeyboardEventDefinition, event: TKeyboardEvent) {\n  if (!isCorrectModifiers(definition, event)) {\n    return false\n  }\n\n  if (\n    definition.code !== undefined &&\n    definition.code.toLowerCase() === event.code.toLowerCase()\n  ) {\n    return true\n  }\n\n  return (\n    definition.key !== undefined &&\n    definition.key.toLowerCase() === event.key.toLowerCase()\n  )\n}\n\nfunction isCorrectModifiers<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'shiftKey' | 'altKey' | 'ctrlKey' | 'metaKey'\n  >,\n>(definition: KeyboardEventDefinition, event: TKeyboardEvent) {\n  return (\n    (definition.ctrl === event.ctrlKey || definition.ctrl === undefined) &&\n    (definition.meta === event.metaKey || definition.meta === undefined) &&\n    (definition.shift === event.shiftKey || definition.shift === undefined) &&\n    (definition.alt === event.altKey || definition.alt === undefined)\n  )\n}\n","import {IS_APPLE} from './is-apple'\nimport {isKeyboardShortcut} from './is-keyboard-shortcut'\nimport type {KeyboardEventDefinition} from './keyboard-event-definition'\n\n/**\n * @beta\n * Definition of a keyboard shortcut with platform-specific keyboard event\n * definitions.\n *\n * `default` keyboard event definitions are required while the `apple`\n * keyboard event definitions are optional.\n *\n * @example\n * ```typescript\n * const boldShortcut: KeyboardShortcutDefinition = {\n *   default: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: true,\n *     meta: false,\n *     shift: false,\n *   }],\n *   apple: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: false,\n *     meta: true,\n *     shift: false,\n *   }],\n * }\n * ```\n */\nexport type KeyboardShortcutDefinition = {\n  default: ReadonlyArray<KeyboardEventDefinition>\n  apple?: ReadonlyArray<KeyboardEventDefinition>\n}\n\n/**\n * @beta\n * A resolved keyboard shortcut for the current platform that has been\n * processed by `createKeyboardShortcut(...)` to select the appropriate\n * platform-specific key combination. The `guard` function determines if the\n * shortcut applies to the current `KeyboardEvent`, while `keys` contains the\n * display-friendly key combination for the current platform.\n */\nexport type KeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  >,\n> = {\n  guard: (event: TKeyboardEvent) => boolean\n  keys: ReadonlyArray<string>\n}\n\n/**\n * @beta\n * Creates a `KeyboardShortcut` from a `KeyboardShortcutDefinition`.\n *\n * `default` keyboard event definitions are required while the `apple`\n * keyboard event definitions are optional.\n *\n * @example\n * ```typescript\n * const shortcut = createKeyboardShortcut({\n *   default: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: true,\n *     meta: false,\n *     shift: false,\n *   }],\n *   apple: [{\n *     key: 'B',\n *     alt: false,\n *     ctrl: false,\n *     meta: true,\n *     shift: false,\n *   }],\n * })\n * ```\n */\nexport function createKeyboardShortcut<\n  TKeyboardEvent extends Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  > = Pick<\n    KeyboardEvent,\n    'key' | 'code' | 'altKey' | 'ctrlKey' | 'metaKey' | 'shiftKey'\n  >,\n>(definition: KeyboardShortcutDefinition): KeyboardShortcut<TKeyboardEvent> {\n  if (IS_APPLE) {\n    const appleDefinition = definition.apple ?? definition.default\n    const firstDefinition = appleDefinition.at(0)\n\n    return {\n      guard: (event) =>\n        appleDefinition.some((definition) =>\n          isKeyboardShortcut(definition, event),\n        ),\n      keys: [\n        ...(firstDefinition?.meta ? [''] : []),\n        ...(firstDefinition?.ctrl ? ['Ctrl'] : []),\n        ...(firstDefinition?.alt ? ['Option'] : []),\n        ...(firstDefinition?.shift ? ['Shift'] : []),\n        ...(firstDefinition?.key !== undefined\n          ? [firstDefinition.key]\n          : firstDefinition?.code !== undefined\n            ? [firstDefinition.code]\n            : []),\n      ],\n    }\n  }\n\n  const firstDefinition = definition.default.at(0)\n\n  return {\n    guard: (event) =>\n      definition.default.some((definition) =>\n        isKeyboardShortcut(definition, event),\n      ),\n    keys: [\n      ...(firstDefinition?.meta ? ['Meta'] : []),\n      ...(firstDefinition?.ctrl ? ['Ctrl'] : []),\n      ...(firstDefinition?.alt ? ['Alt'] : []),\n      ...(firstDefinition?.shift ? ['Shift'] : []),\n      ...(firstDefinition?.key !== undefined\n        ? [firstDefinition.key]\n        : firstDefinition?.code !== undefined\n          ? [firstDefinition.code]\n          : []),\n    ],\n  }\n}\n","import {createKeyboardShortcut} from './keyboard-shortcuts'\n\n/**\n * @beta\n */\nexport const bold = createKeyboardShortcut({\n  default: [\n    {\n      key: 'B',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'B',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const italic = createKeyboardShortcut({\n  default: [\n    {\n      key: 'I',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'I',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const code = createKeyboardShortcut({\n  default: [\n    {\n      key: \"'\",\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: \"'\",\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const underline = createKeyboardShortcut({\n  default: [\n    {\n      key: 'U',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'U',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const strikeThrough = createKeyboardShortcut({\n  default: [\n    {\n      key: 'X',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n  apple: [\n    {\n      key: 'X',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: true,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const link = createKeyboardShortcut({\n  default: [\n    {\n      key: 'K',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'K',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const normal = createKeyboardShortcut({\n  default: [\n    {\n      key: '0',\n      code: 'Digit0',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '0',\n      code: 'Numpad0',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '0',\n      code: 'Digit0',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '0',\n      code: 'Numpad0',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const h1 = createKeyboardShortcut({\n  default: [\n    {\n      key: '1',\n      code: 'Digit1',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '1',\n      code: 'Numpad1',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '1',\n      code: 'Digit1',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '1',\n      code: 'Numpad1',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const h2 = createKeyboardShortcut({\n  default: [\n    {\n      key: '2',\n      code: 'Digit2',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '2',\n      code: 'Numpad2',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '2',\n      code: 'Digit2',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '2',\n      code: 'Numpad2',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const h3 = createKeyboardShortcut({\n  default: [\n    {\n      key: '3',\n      code: 'Digit3',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '3',\n      code: 'Numpad3',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '3',\n      code: 'Digit3',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '3',\n      code: 'Numpad3',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const h4 = createKeyboardShortcut({\n  default: [\n    {\n      key: '4',\n      code: 'Digit4',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '4',\n      code: 'Numpad4',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '4',\n      code: 'Digit4',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '4',\n      code: 'Numpad4',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const h5 = createKeyboardShortcut({\n  default: [\n    {\n      key: '5',\n      code: 'Digit5',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '5',\n      code: 'Numpad5',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '5',\n      code: 'Digit5',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '5',\n      code: 'Numpad5',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const h6 = createKeyboardShortcut({\n  default: [\n    {\n      key: '6',\n      code: 'Digit6',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: '6',\n      code: 'Numpad6',\n      alt: true,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: '6',\n      code: 'Digit6',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n    {\n      key: '6',\n      code: 'Numpad6',\n      alt: true,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const blockquote = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Q',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const undo = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n  ],\n  apple: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: false,\n    },\n  ],\n})\n\n/**\n * @beta\n */\nexport const redo = createKeyboardShortcut({\n  default: [\n    {\n      key: 'Y',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: false,\n    },\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: true,\n      meta: false,\n      shift: true,\n    },\n  ],\n  apple: [\n    {\n      key: 'Z',\n      alt: false,\n      ctrl: false,\n      meta: true,\n      shift: true,\n    },\n  ],\n})\n"],"names":["IS_APPLE","window","test","navigator","userAgent","isKeyboardShortcut","definition","event","isCorrectModifiers","code","undefined","toLowerCase","key","ctrl","ctrlKey","meta","metaKey","shift","shiftKey","alt","altKey","createKeyboardShortcut","appleDefinition","apple","default","firstDefinition","at","guard","some","keys","bold","italic","underline","strikeThrough","link","normal","h1","h2","h3","h4","h5","h6","blockquote","undo","redo"],"mappings":"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","ignoreList":[0,1,2,3],"debugId":null}}]
}